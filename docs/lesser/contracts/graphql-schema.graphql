# DO NOT EDIT: aggregated schema for client consumption
# Generated by scripts/generate_schema.sh

# Lesser GraphQL Schema

scalar Time
scalar Cursor
scalar Upload

# Enums
enum TimelineType {
	HOME
	PUBLIC
	LOCAL
	HASHTAG
	LIST
	DIRECT
	ACTOR
}

enum ActorType {
	PERSON
	GROUP
	APPLICATION
	SERVICE
	ORGANIZATION
}

enum ObjectType {
	NOTE
	ARTICLE
	IMAGE
	VIDEO
	QUESTION
	EVENT
	PAGE
}

enum Visibility {
	PUBLIC
	UNLISTED
	FOLLOWERS
	DIRECT
}

enum Period {
	HOUR
	DAY
	WEEK
	MONTH
	YEAR
}

enum ActivityType {
	CREATE
	UPDATE
	DELETE
	FOLLOW
	LIKE
	ANNOUNCE
	UNDO
	ACCEPT
	REJECT
	FLAG
}

enum TrustCategory {
	CONTENT
	BEHAVIOR
	TECHNICAL
}

# Core Types
type Actor {
	id: ID!
	username: String!
	domain: String
	displayName: String
	summary: String
	avatar: String
	header: String
	followers: Int!
	following: Int!
	statusesCount: Int!
	bot: Boolean!
	locked: Boolean!
	createdAt: Time!
	updatedAt: Time!
	fields: [Field!]!

	# Lesser enhancements
	trustScore: Float!
	reputation: Reputation
	vouches: [Vouch!]!
}

type Field {
	name: String!
	value: String!
	verifiedAt: Time
}

type Object {
	id: ID!
	type: ObjectType!
	actor: Actor!
	content: String!
	contentMap: [ContentMap!]!
	inReplyTo: Object
	visibility: Visibility!
	sensitive: Boolean!
	spoilerText: String
	attachments: [Attachment!]!
	tags: [Tag!]!
	mentions: [Mention!]!
	createdAt: Time!
	updatedAt: Time!
	poll: Poll

	# Engagement metrics
	repliesCount: Int!
	likesCount: Int!
	sharesCount: Int!
	boosted: Boolean!
	relationshipType: ObjectRelationshipType!
	boostedObject: Object

	# Lesser enhancements
	estimatedCost: Int!
	moderationScore: Float
	communityNotes: [CommunityNote!]!

	# Quote Posts extensions
	quoteUrl: String
	quoteable: Boolean!
	quotePermissions: QuotePermission!
	quoteContext: QuoteContext
	quoteCount: Int!
	quotes(first: Int, after: String): QuoteConnection!
}

type ContentMap {
	language: String!
	content: String!
}

type Attachment {
	id: ID!
	type: String!
	url: String!
	preview: String
	description: String
	blurhash: String
	width: Int
	height: Int
	duration: Float
}

type Tag {
	name: String!
	url: String!
}

type Mention {
	id: ID!
	username: String!
	domain: String
	url: String!
}

enum ObjectRelationshipType {
	ORIGINAL
	BOOST
}

type Activity {
	id: ID!
	type: ActivityType!
	actor: Actor!
	object: Object
	target: Object
	published: Time!

	# Lesser enhancement
	cost: Int!
}

# Connections for pagination
type ObjectConnection {
	edges: [ObjectEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type ObjectEdge {
	node: Object!
	cursor: Cursor!
}

type PageInfo {
	hasNextPage: Boolean!
	hasPreviousPage: Boolean!
	startCursor: Cursor
	endCursor: Cursor
}

type ActorListPage {
	actors: [Actor!]!
	nextCursor: Cursor
	totalCount: Int!
}

# Domain block pagination
type DomainBlockPage {
	domains: [String!]!
	nextCursor: Cursor
	totalCount: Int!
}

# Markers (timeline positions)
enum MarkerTimeline {
	HOME
	NOTIFICATIONS
}

type Marker {
	lastReadId: ID!
	updatedAt: Time!
	version: Int!
}

type MarkerSet {
	home: Marker
	notifications: Marker
}

input SaveMarkerInput {
	timeline: MarkerTimeline!
	lastReadId: ID!
}

# Account quote permissions (Mastodon compatibility)
type AccountQuotePermissions {
	username: String!
	allowPublic: Boolean!
	allowFollowers: Boolean!
	allowMentioned: Boolean!
	blockList: [String!]!
}

input UpdateAccountQuotePermissionsInput {
	allowPublic: Boolean
	allowFollowers: Boolean
	allowMentioned: Boolean
	blockList: [String!]
}

# Account registration (passwordless)
input RegisterAccountInput {
	username: String!
	locale: String
	agreement: Boolean!
	reason: String
	defaultPostingVisibility: Visibility
}

type RegisterAccountPayload {
	actor: Actor!
	created: Boolean!
}

# Instance Metrics
type InstanceMetrics {
	activeUsers: Int!
	requestsPerMinute: Int!
	averageLatencyMs: Float!
	storageUsedGB: Float!
	estimatedMonthlyCost: Float!
	lastUpdated: Time!
}

type CostBreakdown {
	period: Period!
	totalCost: Float!
	dynamoDBCost: Float!
	s3StorageCost: Float!
	lambdaCost: Float!
	dataTransferCost: Float!
	breakdown: [CostItem!]!
}

type CostItem {
	operation: String!
	count: Int!
	cost: Float!
}

# Trust & Moderation
type TrustEdge {
	from: Actor!
	to: Actor!
	category: TrustCategory!
	score: Float!
	updatedAt: Time!
}

type ModerationDecision {
	id: ID!
	object: Object!
	decision: String!
	confidence: Float!
	evidence: [String!]!
	reviewers: [Actor!]!
	timestamp: Time!
}

#
# Moderation + reputation parity (REST endpoints)
#

input ModerationReviewInput {
	eventId: ID!
	action: String!
	severity: Int!
	confidence: Float!
	notes: String
}

type ModerationReviewResult {
	reviewId: ID!
	eventId: ID!
	action: String!
	reviewedAt: Time!
}

type ModerationHistoryEvent {
	id: ID!
	eventType: String!
	objectId: ID!
	objectType: String!
	actorId: ID!
	category: String!
	severity: Int!
	confidenceScore: Float!
	reason: String
	createdAt: Time!
	updatedAt: Time!
}

type ModerationHistoryDecision {
	id: ID!
	eventId: ID!
	objectId: ID!
	action: String!
	consensusScore: Float!
	reviewerCount: Int!
	trustWeightTotal: Float!
	decidedAt: Time!
}

type ModerationHistoryTimelineEntry {
	timestamp: Time!
	type: String!
	event: ModerationHistoryEvent
	decision: ModerationHistoryDecision
}

type ModerationHistoryResult {
	objectId: ID!
	events: [ModerationHistoryEvent!]!
	decisions: [ModerationHistoryDecision!]!
	timeline: [ModerationHistoryTimelineEntry!]!
	currentStatus: String!
	lastUpdated: Time!
}

type ModerationConsensusReview {
	reviewerId: ID!
	reviewerDomain: String
	action: String!
	confidence: Float!
	trustWeight: Float!
	reviewedAt: Time!
}

type ModerationConsensusResult {
	eventId: ID!
	objectId: ID!
	category: String!
	severity: Int!
	confidenceScore: Float!
	reviews: [ModerationConsensusReview!]!
	reviewerCount: Int!
	consensusScore: Float
	decision: String
	decidedAt: Time
}

type TrustCategoryScore {
	category: String!
	score: Float!
}

type ModerationTrustScore {
	actorId: ID!
	actorDomain: String
	overallScore: Float!
	scores: [TrustCategoryScore!]!
	trusterCount: Int!
	calculatedAt: Time!
}

input CreateReportInput {
	accountId: ID!
	statusIds: [ID!]
	comment: String
	category: String
	forward: Boolean
	ruleIds: [Int!]
}

type Report {
	id: ID!
	actionTaken: Boolean!
	actionTakenAt: Time
	category: String!
	comment: String
	forwarded: Boolean!
	createdAt: Time!
	statusIds: [ID!]!
	ruleIds: [Int!]!
	targetAccount: Actor
}

input CreateVouchInput {
	to: ID!
	confidence: Float!
	context: String
}

type CommunityNote {
	id: ID!
	author: Actor!
	content: String!
	helpful: Int!
	notHelpful: Int!
	createdAt: Time!
}

# Community note connection for pagination
type CommunityNoteConnection {
	edges: [CommunityNoteEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type CommunityNoteEdge {
	node: CommunityNote!
	cursor: Cursor!
}

# Notification type
type Notification {
	id: ID!
	type: String! # follow, mention, favourite, reblog
	account: Actor! # Who triggered the notification
	status: Object # Related status (if any)
	read: Boolean!
	createdAt: Time!
}

# Status edit history entry (Mastodon compatibility)
type StatusEdit {
	content: String!
	spoilerText: String
	sensitive: Boolean!
	createdAt: Time!
	account: Actor!
}

# Translation result (Mastodon compatibility)
type TranslationResult {
	content: String!
	spoilerText: String
	detectedLanguage: String!
	provider: String!
}

# Instance info (Mastodon compatibility)
type InstanceRule {
	id: ID!
	text: String!
}

type InstanceInfo {
	domain: String!
	title: String!
	shortDescription: String
	description: String!
	email: String
	version: String!
	sourceUrl: String
	streamingUrl: String
	thumbnailUrl: String
	languages: [String!]!
	registrationsOpen: Boolean!
	approvalRequired: Boolean!
	invitesEnabled: Boolean!
	userCount: Int!
	statusCount: Int!
	domainCount: Int!
	contactAccount: Actor
	rules: [InstanceRule!]!
}

type InstanceActivityEntry {
	week: String!
	statuses: Int!
	logins: Int!
	registrations: Int!
}

type InstanceDomainBlock {
	domain: String!
	digest: String!
	severity: String!
	comment: String!
}

type TranslationLanguage {
	code: String!
	name: String!
}

# Announcements (Mastodon compatibility)
type Announcement {
	id: ID!
	content: String!
	text: String!
	publishedAt: Time!
	updatedAt: Time!
	allDay: Boolean!
	startsAt: Time
	endsAt: Time
	read: Boolean!
	reactions: [AnnouncementReaction!]!
}

type AnnouncementReaction {
	name: String!
	count: Int!
	me: Boolean!
	url: String
	staticUrl: String
}

# Notification connection for pagination
type NotificationConnection {
	edges: [NotificationEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type NotificationEdge {
	node: Notification!
	cursor: Cursor!
}

type PushSubscription {
	id: ID!
	endpoint: String!
	keys: PushSubscriptionKeys!
	alerts: PushSubscriptionAlerts!
	policy: String!
	serverKey: String
	createdAt: Time
	updatedAt: Time
}

type PushSubscriptionKeys {
	auth: String!
	p256dh: String!
}

type PushSubscriptionAlerts {
	follow: Boolean!
	favourite: Boolean!
	reblog: Boolean!
	mention: Boolean!
	poll: Boolean!
	followRequest: Boolean!
	status: Boolean!
	update: Boolean!
	adminSignUp: Boolean!
	adminReport: Boolean!
}

# Quote Posts types
type QuoteContext {
	originalAuthor: Actor!
	originalNote: Object
	quoteAllowed: Boolean!
	quoteType: QuoteType!
	withdrawn: Boolean!
}

enum QuotePermission {
	EVERYONE
	FOLLOWERS
	NONE
}

enum QuoteType {
	FULL
	PARTIAL
	COMMENTARY
	REACTION
}

type QuoteConnection {
	edges: [QuoteEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type QuoteEdge {
	node: Object!
	cursor: Cursor!
}

# Quote Posts payloads
type WithdrawQuotePayload {
	success: Boolean!
	note: Object!
	withdrawnCount: Int!
}

type UpdateQuotePermissionsPayload {
	success: Boolean!
	note: Object!
	affectedQuotes: Int!
}

# Conversation type
type Conversation {
	id: ID!
	lastStatus: Object
	unread: Boolean!
	accounts: [Actor!]!
	createdAt: Time!
	updatedAt: Time!
}

# List type
type List {
	id: ID!
	title: String!
	repliesPolicy: RepliesPolicy!
	exclusive: Boolean!
	accountCount: Int!
	accounts: [Actor!]!
	createdAt: Time!
	updatedAt: Time!
}

enum RepliesPolicy {
	FOLLOWED
	LIST
	NONE
}

# Media type
type Media {
	id: ID!
	type: MediaType!
	url: String!
	previewUrl: String
	description: String
	sensitive: Boolean!
	spoilerText: String
	mediaCategory: MediaCategory!
	blurhash: String
	width: Int
	height: Int
	duration: Float
	size: Int!
	mimeType: String!
	uploadedBy: Actor!
	createdAt: Time!
}

enum MediaType {
	IMAGE
	VIDEO
	AUDIO
	UNKNOWN
}

enum MediaCategory {
	IMAGE
	VIDEO
	AUDIO
	GIFV
	DOCUMENT
	UNKNOWN
}

type MediaEdge {
	node: Media!
	cursor: Cursor!
}

type MediaConnection {
	edges: [MediaEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

input MediaFilterInput {
	ownerId: ID
	ownerUsername: String
	mediaType: MediaType
	mimeType: String
	since: Time
	until: Time
}

# Custom Emoji type
type CustomEmoji {
	id: ID!
	shortcode: String!
	url: String!
	staticUrl: String!
	visibleInPicker: Boolean!
	category: String
	domain: String
	createdAt: Time!
	updatedAt: Time!
}

# Scheduled Status type
type ScheduledStatus {
	id: ID!
	scheduledAt: Time!
	params: StatusParams!
	mediaAttachments: [Media!]!
	createdAt: Time!
}

type StatusParams {
	text: String!
	visibility: Visibility!
	sensitive: Boolean!
	spoilerText: String
	inReplyToId: ID
	language: String
	poll: PollParams
}

type PollParams {
	options: [String!]!
	expiresIn: Int!
	multiple: Boolean
	hideTotals: Boolean
}

type Poll {
	id: ID!
	expiresAt: Time
	expired: Boolean!
	multiple: Boolean!
	hideTotals: Boolean!
	votesCount: Int!
	votersCount: Int!
	voted: Boolean!
	ownVotes: [Int!]
	options: [PollOption!]!
}

type PollOption {
	title: String!
	votesCount: Int!
}

# Enhanced Search types
type SearchResult {
	accounts: [Actor!]!
	statuses: [Object!]!
	hashtags: [Tag!]!
}

type AccountSuggestion {
	account: Actor!
	source: SuggestionSource!
	reason: String
}

enum SuggestionSource {
	STAFF
	PAST_INTERACTIONS
	GLOBAL
	SIMILAR_PROFILES
}

# Directory type for profile discovery
type ProfileDirectory {
	accounts: [Actor!]!
	totalCount: Int!
}

# Relationship type
type Relationship {
	id: ID!
	following: Boolean!
	followedBy: Boolean!
	blocking: Boolean!
	blockedBy: Boolean!
	muting: Boolean!
	mutingNotifications: Boolean!
	requested: Boolean!
	domainBlocking: Boolean!
	showingReblogs: Boolean!
	notifying: Boolean!
	languages: [String!]
	note: String
}

# Input Types
input CreateNoteInput {
	content: String!
	contentMap: [ContentMapInput!]
	inReplyToId: ID
	quoteId: ID
	visibility: Visibility!
	sensitive: Boolean
	spoilerText: String
	attachmentIds: [ID!]
	mentions: [String!]
	tags: [String!]
	poll: PollParamsInput
}

input UpdateStatusInput {
	content: String!
	sensitive: Boolean
	spoilerText: String
	language: String
	attachmentIds: [ID!]
}

input ContentMapInput {
	language: String!
	content: String!
}

input TrustInput {
	targetActorId: ID!
	category: TrustCategory!
	score: Float!
}

input FlagInput {
	objectId: ID!
	reason: String!
	evidence: [String!]
}

input CommunityNoteInput {
	objectId: ID!
	content: String!
}

input CreateQuoteNoteInput {
	content: String!
	quoteUrl: String!
	quoteType: QuoteType
	visibility: Visibility
	quoteable: Boolean
	sensitive: Boolean
	spoilerText: String
	mediaIds: [ID!]
}

# List inputs
input CreateListInput {
	title: String!
	repliesPolicy: RepliesPolicy
	exclusive: Boolean
}

input UpdateListInput {
	title: String
	repliesPolicy: RepliesPolicy
	exclusive: Boolean
}

# Media inputs
input UploadMediaInput {
	file: Upload!
	filename: String
	description: String
	focus: FocusInput
	sensitive: Boolean
	spoilerText: String
	mediaType: MediaCategory
}

input UpdateMediaInput {
	description: String
	focus: FocusInput
}

input FocusInput {
	x: Float!
	y: Float!
}

# Scheduled status inputs
input ScheduleStatusInput {
	text: String!
	scheduledAt: Time!
	visibility: Visibility
	sensitive: Boolean
	spoilerText: String
	inReplyToId: ID
	language: String
	mediaIds: [ID!]
	poll: PollParamsInput
}

input PollParamsInput {
	options: [String!]!
	expiresIn: Int!
	multiple: Boolean
	hideTotals: Boolean
}

input UpdateScheduledStatusInput {
	scheduledAt: Time!
}

# Relationship inputs
input UpdateRelationshipInput {
	notify: Boolean
	showReblogs: Boolean
	languages: [String!]
	note: String
}

input ProfileFieldInput {
	name: String!
	value: String!
	verifiedAt: Time
}

input UpdateProfileInput {
	displayName: String
	bio: String
	avatar: String
	header: String
	locked: Boolean
	bot: Boolean
	discoverable: Boolean
	noIndex: Boolean
	sensitive: Boolean
	language: String
	fields: [ProfileFieldInput!]
}

input PushSubscriptionKeysInput {
	auth: String!
	p256dh: String!
}

input PushSubscriptionAlertsInput {
	follow: Boolean
	favourite: Boolean
	reblog: Boolean
	mention: Boolean
	poll: Boolean
	followRequest: Boolean
	status: Boolean
	update: Boolean
	adminSignUp: Boolean
	adminReport: Boolean
}

input RegisterPushSubscriptionInput {
	endpoint: String!
	keys: PushSubscriptionKeysInput!
	alerts: PushSubscriptionAlertsInput!
}

input UpdatePushSubscriptionInput {
	alerts: PushSubscriptionAlertsInput!
}

# Emoji inputs
input CreateEmojiInput {
	shortcode: String!
	image: String! # URL or base64
	category: String
	visibleInPicker: Boolean
}

input UpdateEmojiInput {
	category: String
	visibleInPicker: Boolean
}

# Search/Discovery inputs
input DirectoryFiltersInput {
	local: Boolean
	remote: Boolean
	active: Boolean
	order: DirectoryOrder
}

enum DirectoryOrder {
	ACTIVE
	NEW
}

# Payloads
type CreateNotePayload {
	object: Object!
	activity: Activity!
	cost: CostUpdate!
}

type FlagPayload {
	moderationId: ID!
	queued: Boolean!
}

type CommunityNotePayload {
	note: CommunityNote!
	object: Object!
}

# Updates
type CostUpdate {
	operationCost: Int!
	dailyTotal: Float!
	monthlyProjection: Float!
}

# Queries
type Query {
	# Mastodon compatibility
	viewer: Actor!
	actor(id: ID, username: String): Actor
	object(id: ID!): Object
	timeline(
		type: TimelineType!
		hashtag: String
		listId: ID
		actorId: ID
		first: Int = 20
		after: Cursor
		mediaOnly: Boolean = false
	): ObjectConnection!
	search(query: String!, type: String, first: Int = 20, after: Cursor): SearchResult!
	notifications(
		types: [String!]
		excludeTypes: [String!]
		first: Int = 20
		after: Cursor
	): NotificationConnection!
	notification(id: ID!): Notification
	statusHistory(id: ID!, limit: Int = 100): [StatusEdit!]!
	statusFavouritedBy(id: ID!, first: Int = 40, after: Cursor): ActorListPage!
	statusRebloggedBy(id: ID!, first: Int = 40, after: Cursor): ActorListPage!
	linkTimeline(url: String!, first: Int = 20, after: Cursor): ObjectConnection!
	translateStatus(id: ID!, targetLanguage: String): TranslationResult!
	instance: InstanceInfo!
	instanceActivity(limit: Int = 12): [InstanceActivityEntry!]!
	instancePeers(limit: Int = 100): [String!]!
	instanceDomainBlocks(limit: Int = 100): [InstanceDomainBlock!]!
	translationLanguages: [TranslationLanguage!]!
	announcements: [Announcement!]!

	# Accounts + relationships
	accountQuotePermissions(username: String!): AccountQuotePermissions!
	blocks(first: Int = 40, after: Cursor): ActorListPage!
	mutes(first: Int = 40, after: Cursor): ActorListPage!
	endorsements: [Actor!]!
	followRequests(first: Int = 100, after: Cursor): ActorListPage!
	domainBlocks(first: Int = 100, after: Cursor): DomainBlockPage!
	markers(timelines: [MarkerTimeline!]): MarkerSet!

	# Account activity
	favourites(first: Int = 20, after: Cursor): ObjectConnection!
	bookmarks(first: Int = 20, after: Cursor): ObjectConnection!
	communityNotesByAuthor(
		username: String!
		first: Int = 20
		after: Cursor
	): CommunityNoteConnection!

	# Conversations
	conversations(first: Int = 20, after: Cursor): [Conversation!]!
	conversation(id: ID!): Conversation

	# Lists
	lists: [List!]!
	list(id: ID!): List
	listAccounts(id: ID!): [Actor!]!

	# Media
	media(id: ID!): Media
	mediaLibrary(filter: MediaFilterInput, first: Int = 20, after: Cursor): MediaConnection!

	# Custom Emojis
	customEmojis: [CustomEmoji!]!

	# Scheduled Statuses
	scheduledStatuses(first: Int = 20, after: Cursor): [ScheduledStatus!]!
	scheduledStatus(id: ID!): ScheduledStatus

	# Relationships
	relationship(id: ID!): Relationship
	relationships(ids: [ID!]!): [Relationship!]!
	followers(username: String!, limit: Int = 40, cursor: Cursor): ActorListPage!
	following(username: String!, limit: Int = 40, cursor: Cursor): ActorListPage!
	userPreferences: UserPreferences!
	pushSubscription: PushSubscription

	# Discovery
	profileDirectory(
		filters: DirectoryFiltersInput
		first: Int = 40
		after: Cursor
	): ProfileDirectory!
	suggestions(limit: Int = 40): [AccountSuggestion!]!
	removeSuggestion(accountId: ID!): Boolean!

	# Data portability
	exports(first: Int = 20, after: Cursor): ExportJobConnection!
	export(id: ID!): ExportJob
	imports(first: Int = 20, after: Cursor): ImportJobConnection!
	import(id: ID!): ImportJob

	# Filters (Mastodon v2)
	filters: [Filter!]!
	filter(id: ID!): Filter

	# Trends (Mastodon v2)
	trends(limit: Int = 10): [TrendingItem!]!
	trendingTags(limit: Int = 10): [TrendingTag!]!
	trendingStatuses(limit: Int = 20): [TrendingStatus!]!
	trendingLinks(limit: Int = 10): [TrendingLink!]!

	# Grouped notifications (Mastodon v2)
	groupedNotifications(input: GroupedNotificationsInput): [GroupedNotificationGroup!]!

	# Lesser enhancements
	instanceMetrics: InstanceMetrics!
	costBreakdown(period: Period = DAY): CostBreakdown!
	trustGraph(actorId: ID!, category: TrustCategory): [TrustEdge!]!
	moderationQueue(first: Int = 20, after: Cursor): [ModerationDecision!]!
	moderationConsensus(eventId: ID!): ModerationConsensusResult!
	moderationHistory(objectId: ID!): ModerationHistoryResult!
	moderationTrustScore(actorId: ID!): ModerationTrustScore!
	reputation(actorId: ID!): Reputation!
	vouches(actorId: ID!): [Vouch!]!

	# Debug endpoints
	explainObject(id: ID!): ObjectExplanation!
	federationStatus(domain: String!): FederationStatus!

	# AI Analysis
	aiAnalysis(objectId: ID!): AIAnalysis
	aiStats(period: Period!): AIStats!
	aiCapabilities: AICapabilities!

	# Hashtag Following queries
	hashtag(name: String!): Hashtag
	followedHashtags(first: Int, after: String): HashtagConnection!
	hashtagTimeline(
		hashtag: String!
		first: Int
		after: String
		mediaOnly: Boolean = false
	): PostConnection!
	multiHashtagTimeline(
		hashtags: [String!]!
		mode: HashtagMode!
		first: Int
		after: String
	): PostConnection!
	suggestedHashtags(limit: Int): [HashtagSuggestion!]!

	# Thread Synchronization queries
	threadContext(noteId: ID!): ThreadContext

	# Severed Relationships queries
	severedRelationships(instance: String, first: Int, after: String): SeveredRelationshipConnection!

	affectedRelationships(severedRelationshipId: ID!): AffectedRelationshipConnection!
}

# Mutations
type Mutation {
	# Accounts
	registerAccount(input: RegisterAccountInput!): RegisterAccountPayload!
	updateAccountQuotePermissions(
		input: UpdateAccountQuotePermissionsInput!
	): AccountQuotePermissions!
	acceptFollowRequest(accountId: ID!): Relationship!
	rejectFollowRequest(accountId: ID!): Relationship!
	addDomainBlock(domain: String!): Boolean!
	removeDomainBlock(domain: String!): Boolean!
	saveMarkers(input: [SaveMarkerInput!]!): MarkerSet!

	# Mastodon compatibility - Status operations
	createNote(input: CreateNoteInput!): CreateNotePayload!
	updateStatus(id: ID!, input: UpdateStatusInput!): Object!
	deleteObject(id: ID!): Boolean!
	likeObject(id: ID!): Activity!
	unlikeObject(id: ID!): Boolean!
	shareObject(id: ID!): Object!
	unshareObject(id: ID!): Object!
	bookmarkObject(id: ID!): Object!
	unbookmarkObject(id: ID!): Boolean!
	pinObject(id: ID!): Object!
	unpinObject(id: ID!): Boolean!
	muteStatus(id: ID!, durationSeconds: Int): Boolean!
	unmuteStatus(id: ID!): Boolean!
	dismissAnnouncement(id: ID!): Boolean!
	addAnnouncementReaction(id: ID!, name: String!): Boolean!
	removeAnnouncementReaction(id: ID!, name: String!): Boolean!

	# Relationship operations
	followActor(id: ID!): Activity!
	unfollowActor(id: ID!): Boolean!
	blockActor(id: ID!): Relationship!
	unblockActor(id: ID!): Boolean!
	muteActor(id: ID!, notifications: Boolean): Relationship!
	unmuteActor(id: ID!): Boolean!
	updateRelationship(id: ID!, input: UpdateRelationshipInput!): Relationship!
	updateProfile(input: UpdateProfileInput!): Actor!

	# List operations
	createList(input: CreateListInput!): List!
	updateList(id: ID!, input: UpdateListInput!): List!
	deleteList(id: ID!): Boolean!
	addAccountsToList(id: ID!, accountIds: [ID!]!): List!
	removeAccountsFromList(id: ID!, accountIds: [ID!]!): List!

	# Conversation operations
	markConversationAsRead(id: ID!): Conversation!
	deleteConversation(id: ID!): Boolean!

	# Media operations
	uploadMedia(input: UploadMediaInput!): UploadMediaPayload!
	updateMedia(id: ID!, input: UpdateMediaInput!): Media!

	# Notification operations
	dismissNotification(id: ID!): Boolean!
	clearNotifications: Boolean!
	markNotificationGroupAsRead(groupId: ID!): Boolean!
	updateUserPreferences(input: UpdateUserPreferencesInput!): UserPreferences!
	updateStreamingPreferences(input: StreamingPreferencesInput!): UserPreferences!
	registerPushSubscription(input: RegisterPushSubscriptionInput!): PushSubscription!
	updatePushSubscription(input: UpdatePushSubscriptionInput!): PushSubscription!
	deletePushSubscription: Boolean!

	# Data portability
	createExport(input: CreateExportInput!): ExportJob!
	createImport(input: CreateImportInput!): ImportJob!
	cancelImport(id: ID!): ImportJob!

	# Filters (Mastodon v2)
	createFilter(input: CreateFilterInput!): Filter!
	updateFilter(id: ID!, input: UpdateFilterInput!): Filter!
	deleteFilter(id: ID!): Boolean!
	addFilterKeyword(filterId: ID!, input: AddFilterKeywordInput!): FilterKeyword!
	deleteFilterKeyword(filterId: ID!, keywordId: ID!): Boolean!
	addFilterStatus(filterId: ID!, statusId: ID!): FilterStatus!
	deleteFilterStatus(filterId: ID!, filterStatusId: ID!): Boolean!
	testFilters(input: FilterTestInput!): FilterTestPayload!

	# Scheduled status operations
	scheduleStatus(input: ScheduleStatusInput!): ScheduledStatus!
	updateScheduledStatus(id: ID!, input: UpdateScheduledStatusInput!): ScheduledStatus!
	cancelScheduledStatus(id: ID!): Boolean!

	# Custom emoji operations (admin)
	createEmoji(input: CreateEmojiInput!): CustomEmoji!
	updateEmoji(shortcode: String!, input: UpdateEmojiInput!): CustomEmoji!
	deleteEmoji(shortcode: String!): Boolean!

	# Lesser enhancements
	updateTrust(input: TrustInput!): TrustEdge!
	flagObject(input: FlagInput!): FlagPayload!
	submitModerationReview(input: ModerationReviewInput!): ModerationReviewResult!
	createReport(input: CreateReportInput!): Report!
	exportReputation: PortableReputation!
	importReputation(document: String!): ReputationImportResult!
	verifyReputation(document: String!): ReputationVerificationResult!
	createVouch(input: CreateVouchInput!): Vouch!
	revokeVouch(id: ID!): Boolean!
	addCommunityNote(input: CommunityNoteInput!): CommunityNotePayload!
	voteCommunityNote(id: ID!, helpful: Boolean!): CommunityNote!

	# AI Analysis
	requestAIAnalysis(objectId: ID!, objectType: String, force: Boolean): AIAnalysisRequest!

	# Quote Posts mutations
	createQuoteNote(input: CreateQuoteNoteInput!): CreateNotePayload!
	withdrawFromQuotes(noteId: ID!): WithdrawQuotePayload!
	updateQuotePermissions(
		noteId: ID!
		quoteable: Boolean!
		permission: QuotePermission!
	): UpdateQuotePermissionsPayload!

	# Hashtag Following mutations
	followHashtag(hashtag: String!, notifyLevel: NotificationLevel): HashtagFollowPayload!
	unfollowHashtag(hashtag: String!): UnfollowHashtagPayload!
	updateHashtagNotifications(
		hashtag: String!
		settings: HashtagNotificationSettingsInput!
	): UpdateHashtagNotificationsPayload!
	muteHashtag(hashtag: String!, until: Time): MuteHashtagPayload!

	# Thread Synchronization mutations
	syncThread(noteUrl: String!, depth: Int): SyncThreadPayload!
	syncMissingReplies(noteId: ID!): SyncRepliesPayload!

	# Severed Relationships mutations
	acknowledgeSeverance(id: ID!): AcknowledgePayload!
	attemptReconnection(id: ID!): ReconnectionPayload!
}

type UploadMediaPayload {
	media: Media!
	uploadId: ID!
	warnings: [String!]
}

# Subscriptions (via WebSocket Lambda)
type Subscription {
	# Activity streams
	activityStream(types: [ActivityType!]): Activity!
	timelineUpdates(type: TimelineType!, listId: ID): Object!

	# Notification stream
	notificationStream(types: [String!]): Notification!

	# Conversation updates
	conversationUpdates: Conversation!

	# List updates
	listUpdates(listId: ID!): ListUpdate!

	# Relationship changes
	relationshipUpdates(actorId: ID): RelationshipUpdate!

	# Lesser enhancements
	costUpdates(threshold: Int): CostUpdate!
	moderationEvents(actorId: ID): ModerationDecision!
	trustUpdates(actorId: ID!): TrustEdge!

	# AI Analysis
	aiAnalysisUpdates(objectId: ID): AIAnalysis!

	# Quote Posts subscription
	quoteActivity(noteId: ID!): QuoteActivityUpdate!

	# Hashtag Following subscription
	hashtagActivity(hashtags: [String!]!): HashtagActivityUpdate!

	# Real-time Metrics Updates subscription
	metricsUpdates(categories: [String!], services: [String!], threshold: Float): MetricsUpdate!
}

# Quote activity update type
type QuoteActivityUpdate {
	type: String! # "quoted", "withdrawn", "permission_changed"
	quote: Object
	quoter: Actor
	timestamp: Time!
}

# List update type
type ListUpdate {
	type: String! # "created", "updated", "deleted", "account_added", "account_removed"
	list: List!
	account: Actor
	timestamp: Time!
}

# Relationship update type
type RelationshipUpdate {
	type: String! # "followed", "unfollowed", "blocked", "unblocked", "muted", "unmuted"
	relationship: Relationship!
	actor: Actor!
	timestamp: Time!
}

# Hashtag Following types
type Hashtag {
	name: String!
	displayName: String!
	url: String!
	followerCount: Int!
	postCount: Int!
	trendingScore: Float!
	isFollowing: Boolean!
	followedAt: Time
	notificationSettings: HashtagNotificationSettings
	posts(first: Int, after: String): PostConnection!
	relatedHashtags: [Hashtag!]!
	analytics: HashtagAnalytics!
}

type HashtagNotificationSettings {
	level: NotificationLevel!
	muted: Boolean!
	mutedUntil: Time
	filters: [NotificationFilter!]!
}

enum NotificationLevel {
	ALL
	MUTUALS
	FOLLOWING
	NONE
}

type NotificationFilter {
	type: String!
	value: String!
}

type PostConnection {
	edges: [PostEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type PostEdge {
	node: Object!
	cursor: Cursor!
}

type HashtagConnection {
	edges: [HashtagEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type HashtagEdge {
	node: Hashtag!
	cursor: Cursor!
}

type HashtagSuggestion {
	hashtag: Hashtag!
	reason: String!
	score: Float!
}

type HashtagAnalytics {
	hourlyPosts: [Int!]!
	dailyPosts: [Int!]!
	topPosters: [Actor!]!
	sentiment: Float!
	engagement: Float!
}

enum HashtagMode {
	ANY # Posts with any of the hashtags
	ALL # Posts with all of the hashtags
}

# Hashtag Following payloads
type HashtagFollowPayload {
	success: Boolean!
	hashtag: Hashtag!
}

type UnfollowHashtagPayload {
	success: Boolean!
	hashtag: Hashtag!
}

type UpdateHashtagNotificationsPayload {
	success: Boolean!
	hashtag: Hashtag!
	settings: HashtagNotificationSettings!
}

type MuteHashtagPayload {
	success: Boolean!
	hashtag: Hashtag!
	mutedUntil: Time
}

type HashtagActivityUpdate {
	hashtag: String!
	post: Object!
	author: Actor!
	timestamp: Time!
}

# Real-time metrics update type for GraphQL subscriptions
type MetricsUpdate {
	metricId: String!
	serviceName: String!
	metricType: String!
	subscriptionCategory: String! # moderation, security, performance, federation, cost, etc.
	aggregationLevel: String! # raw, 5min, hourly, daily
	timestamp: Time!
	count: Int!
	sum: Float!
	min: Float!
	max: Float!
	average: Float!
	p50: Float
	p95: Float
	p99: Float
	unit: String
	userCostMicrocents: Int
	totalCostMicrocents: Int
	dimensions: [MetricsDimension!]!
	userId: String
	tenantId: String
	instanceDomain: String
}

# Key-value pair for metrics dimensions
type MetricsDimension {
	key: String!
	value: String!
}

input HashtagNotificationSettingsInput {
	level: NotificationLevel!
	muted: Boolean
	mutedUntil: Time
	filters: [NotificationFilterInput!]
}

input NotificationFilterInput {
	type: String!
	value: String!
}

# Debug types
type ObjectExplanation {
	object: Object!
	storageLocation: String!
	sizeBytes: Int!
	storageCost: Float!
	accessPattern: [AccessLog!]!
}

type AccessLog {
	timestamp: Time!
	operation: String!
	cost: Int!
}

type FederationStatus {
	domain: String!
	reachable: Boolean!
	lastContact: Time
	sharedInbox: String
	publicKey: String
	software: String
	version: String
}

# Reputation types
type Reputation {
	actorId: ID!
	instance: String!
	totalScore: Int!
	trustScore: Int!
	activityScore: Int!
	moderationScore: Int!
	communityScore: Int!
	calculatedAt: Time!
	version: String!
	evidence: ReputationEvidence!
	signature: String
}

type ReputationEvidence {
	totalPosts: Int!
	totalFollowers: Int!
	accountAge: Int!
	vouchCount: Int!
	trustingActors: Int!
	averageTrustScore: Float!
}

type Vouch {
	id: ID!
	from: Actor!
	to: Actor!
	confidence: Float!
	context: String!
	voucherReputation: Int!
	createdAt: Time!
	expiresAt: Time!
	active: Boolean!
	revoked: Boolean!
	revokedAt: Time
}

type PortableReputation {
	context: [String!]!
	type: String!
	actor: String!
	reputation: Reputation!
	vouches: [Vouch!]!
	issuedAt: Time!
	expiresAt: Time!
	issuer: String!
	issuerProof: String!
}

type ReputationVerificationResult {
	valid: Boolean!
	actorId: String!
	issuer: String!
	issuedAt: Time!
	expiresAt: Time!
	signatureValid: Boolean!
	notExpired: Boolean!
	issuerTrusted: Boolean!
	error: String
}

type ReputationImportResult {
	success: Boolean!
	actorId: String!
	previousScore: Int!
	importedScore: Int!
	vouchesImported: Int!
	message: String
	error: String
}

"""
AI Analysis types
"""
type AIAnalysis {
	id: ID!
	objectId: ID!
	objectType: String!
	textAnalysis: TextAnalysis
	imageAnalysis: ImageAnalysis
	aiDetection: AIDetection
	spamAnalysis: SpamAnalysis
	overallRisk: Float!
	moderationAction: ModerationAction!
	confidence: Float!
	analyzedAt: Time!
}

type TextAnalysis {
	sentiment: Sentiment!
	sentimentScores: SentimentScores!
	toxicityScore: Float!
	toxicityLabels: [String!]!
	containsPII: Boolean!
	dominantLanguage: String!
	entities: [Entity!]!
	keyPhrases: [String!]!
}

type SentimentScores {
	positive: Float!
	negative: Float!
	neutral: Float!
	mixed: Float!
}

type Entity {
	type: String!
	text: String!
	score: Float!
}

type ImageAnalysis {
	moderationLabels: [ModerationLabel!]!
	isNSFW: Boolean!
	nsfwConfidence: Float!
	violenceScore: Float!
	weaponsDetected: Boolean!
	detectedText: [String!]!
	textToxicity: Float!
	celebrityFaces: [Celebrity!]!
	deepfakeScore: Float!
}

type ModerationLabel {
	name: String!
	confidence: Float!
	parentName: String
}

type Celebrity {
	name: String!
	confidence: Float!
	urls: [String!]!
}

type AIDetection {
	aiGeneratedProbability: Float!
	generationModel: String
	patternConsistency: Float!
	styleDeviation: Float!
	semanticCoherence: Float!
	suspiciousPatterns: [String!]!
}

type SpamAnalysis {
	spamScore: Float!
	spamIndicators: [SpamIndicator!]!
	postingVelocity: Float!
	repetitionScore: Float!
	linkDensity: Float!
	followerRatio: Float!
	interactionRate: Float!
	accountAgeDays: Int!
}

type SpamIndicator {
	type: String!
	description: String!
	severity: Float!
}

type AIStats {
	period: String!
	totalAnalyses: Int!
	toxicContent: Int!
	spamDetected: Int!
	aiGenerated: Int!
	nsfwContent: Int!
	piiDetected: Int!
	toxicityRate: Float!
	spamRate: Float!
	aiContentRate: Float!
	nsfwRate: Float!
	moderationActions: ModerationActionCounts!
}

type ModerationActionCounts {
	none: Int!
	flag: Int!
	hide: Int!
	remove: Int!
	shadowBan: Int!
	review: Int!
}

type AIAnalysisRequest {
	message: String!
	objectId: ID!
	estimatedTime: String!
}

enum Sentiment {
	POSITIVE
	NEGATIVE
	NEUTRAL
	MIXED
}

enum ModerationAction {
	NONE
	FLAG
	HIDE
	REMOVE
	SHADOW_BAN
	REVIEW
}

type AICapabilities {
	textAnalysis: TextAnalysisCapabilities!
	imageAnalysis: ImageAnalysisCapabilities!
	aiDetection: AIDetectionCapabilities!
	moderationActions: [String!]!
	costPerAnalysis: CostBreakdown!
}

type TextAnalysisCapabilities {
	sentimentAnalysis: Boolean!
	toxicityDetection: Boolean!
	spamDetection: Boolean!
	piiDetection: Boolean!
	entityExtraction: Boolean!
	languageDetection: Boolean!
}

type ImageAnalysisCapabilities {
	nsfwDetection: Boolean!
	violenceDetection: Boolean!
	textExtraction: Boolean!
	celebrityRecognition: Boolean!
	deepfakeDetection: Boolean!
}

type AIDetectionCapabilities {
	aiGeneratedContent: Boolean!
	patternAnalysis: Boolean!
	styleConsistency: Boolean!
}

# Thread Synchronization types
type ThreadContext {
	rootNote: Object!
	replyCount: Int!
	participantCount: Int!
	lastActivity: Time!
	missingPosts: Int!
	syncStatus: SyncStatus!
}

enum SyncStatus {
	COMPLETE
	PARTIAL
	SYNCING
	FAILED
}

type SyncThreadPayload {
	success: Boolean!
	thread: ThreadContext!
	syncedPosts: Int!
	errors: [String!]
}

type SyncRepliesPayload {
	success: Boolean!
	syncedReplies: Int!
	thread: ThreadContext!
}

# Severed Relationships types
type SeveredRelationship {
	id: ID!
	localInstance: String!
	remoteInstance: String!
	reason: SeveranceReason!
	affectedFollowers: Int!
	affectedFollowing: Int!
	timestamp: Time!
	reversible: Boolean!
	details: SeveranceDetails
}

enum SeveranceReason {
	DOMAIN_BLOCK
	INSTANCE_DOWN
	DEFEDERATION
	POLICY_VIOLATION
	OTHER
}

type SeveranceDetails {
	description: String!
	metadata: [String!]!
	adminNotes: String
	autoDetected: Boolean!
}

type SeveredRelationshipConnection {
	edges: [SeveredRelationshipEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type SeveredRelationshipEdge {
	node: SeveredRelationship!
	cursor: Cursor!
}

type AffectedRelationship {
	actor: Actor!
	relationshipType: String! # "follower" or "following"
	establishedAt: Time!
	lastInteraction: Time
}

type AffectedRelationshipConnection {
	edges: [AffectedRelationshipEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type AffectedRelationshipEdge {
	node: AffectedRelationship!
	cursor: Cursor!
}

type AcknowledgePayload {
	success: Boolean!
	severedRelationship: SeveredRelationship!
	acknowledged: Boolean!
}

type ReconnectionPayload {
	success: Boolean!
	severedRelationship: SeveredRelationship!
	reconnected: Int!
	failed: Int!
	errors: [String!]
}

# =============================================================================
# DATA PORTABILITY (IMPORTS / EXPORTS)
# =============================================================================

enum ExportType {
	ARCHIVE
	FOLLOWERS
	FOLLOWING
	BLOCKS
	MUTES
	LISTS
	BOOKMARKS
}

enum ExportFormat {
	ACTIVITYPUB
	MASTODON
	CSV
}

input DateRangeInput {
	start: Time!
	end: Time!
}

input CreateExportInput {
	type: ExportType!
	format: ExportFormat!
	includeMedia: Boolean = false
	dateRange: DateRangeInput
}

type ExportJob {
	id: ID!
	status: String!
	type: ExportType!
	format: ExportFormat!
	createdAt: Time!
	downloadUrl: String
	expiresAt: Time
	fileSize: Int
	recordCount: Int
	error: String
}

type ExportJobEdge {
	node: ExportJob!
	cursor: Cursor!
}

type ExportJobConnection {
	edges: [ExportJobEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

enum ImportType {
	FOLLOWERS
	FOLLOWING
	BLOCKS
	MUTES
	LISTS
	BOOKMARKS
}

enum ImportMode {
	MERGE
	OVERWRITE
}

input CreateImportInput {
	type: ImportType!
	mode: ImportMode = MERGE
	file: Upload!
	filename: String
}

type ImportResults {
	success: Int!
	skipped: Int!
	failed: Int!
}

type ImportJob {
	id: ID!
	status: String!
	type: ImportType!
	createdAt: Time!
	processed: Int!
	total: Int
	errors: [String!]!
	results: ImportResults
}

type ImportJobEdge {
	node: ImportJob!
	cursor: Cursor!
}

type ImportJobConnection {
	edges: [ImportJobEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

# =============================================================================
# FILTERS (MASTODON V2)
# =============================================================================

enum FilterAction {
	WARN
	HIDE
	BLUR
}

type Filter {
	id: ID!
	title: String!
	context: [String!]!
	expiresAt: String
	filterAction: String!
	keywords: [FilterKeyword!]
	statuses: [FilterStatus!]
}

type FilterKeyword {
	id: ID!
	keyword: String!
	wholeWord: Boolean!
}

type FilterStatus {
	id: ID!
	statusId: String!
}

input CreateFilterKeywordInput {
	keyword: String!
	wholeWord: Boolean = false
}

input CreateFilterInput {
	title: String!
	context: [String!]!
	filterAction: FilterAction = WARN
	expiresInSeconds: Int
	keywords: [CreateFilterKeywordInput!]
}

input UpdateFilterInput {
	title: String
	context: [String!]
	filterAction: FilterAction
	expiresInSeconds: Int
}

input AddFilterKeywordInput {
	keyword: String!
	wholeWord: Boolean = false
}

input FilterTestInput {
	content: String!
	context: [String!]!
}

type FilterTestResult {
	action: String!
	severity: String!
	matchScore: Float!
	matchedRules: [String!]!
	filterId: ID!
	filterTitle: String!
}

type FilterTestPayload {
	content: String!
	totalFilters: Int!
	matchedCount: Int!
	results: [FilterTestResult!]!
}

# =============================================================================
# TRENDS (MASTODON V2)
# =============================================================================

type TrendingTag {
	name: String!
	url: String!
	history: [Int!]!
	uses: Int!
	accounts: Int!
}

type TrendingStatus {
	id: ID!
	url: String!
	authorId: ID!
	content: String!
	engagements: Int!
	publishedAt: Time!
}

type TrendingLink {
	url: String!
	title: String!
	description: String!
	type: String!
	authorName: String!
	image: String!
	shares: Int!
}

enum TrendingItemType {
	HASHTAG
	STATUS
	LINK
}

type TrendingItem {
	type: TrendingItemType!
	hashtag: TrendingTag
	status: TrendingStatus
	link: TrendingLink
}

# =============================================================================
# GROUPED NOTIFICATIONS (MASTODON V2)
# =============================================================================

input GroupingStrategyInput {
	timeWindowHours: Int
	maxGroupSize: Int
	minGroupSize: Int
	sampleSize: Int
	groupByType: Boolean
	groupByTarget: Boolean
}

input GroupedNotificationsInput {
	types: [String!]
	excludeTypes: [String!]
	first: Int = 20
	after: Cursor
	includeAll: Boolean = false
	options: GroupingStrategyInput
}

type GroupedNotificationGroup {
	id: ID!
	type: String!
	groupKey: String!
	count: Int!
	latestCreatedAt: Time!
	earliestCreatedAt: Time!
	read: Boolean!
	summary: String!
	sampleActors: [Actor!]!
	sampleActorIds: [ID!]!
	targetStatusId: ID
	mostRecentNotificationId: ID
	allNotificationIds: [ID!]!
}

# Phase 1: CMS GraphQL surface (headless publishing)

enum ContentFormat {
	HTML
	MARKDOWN
}

enum DraftStatus {
	DRAFT
	SCHEDULED
	PUBLISHING
	PUBLISHED
	FAILED
}

enum ChangeType {
	CREATE
	UPDATE
	RESTORE
}

enum PublicationRole {
	OWNER
	EDITOR
	WRITER
	CONTRIBUTOR
}

type TOCEntry {
	id: String!
	level: Int!
	text: String!
}

type Article {
	id: ID!
	slug: String!
	author: Actor!

	title: String!
	subtitle: String
	excerpt: String

	content: String!
	contentFormat: ContentFormat!

	featuredImage: Media
	tableOfContents: [TOCEntry!]!

	readingTimeMinutes: Int!
	wordCount: Int!

	series: Series
	seriesOrder: Int
	categories: [Category!]!

	seoTitle: String
	seoDescription: String
	canonicalUrl: String
	ogImage: String

	editorNotes: String
	reviewStatus: String

	publishedAt: Time!
	createdAt: Time!
	updatedAt: Time!
}

type ArticleEdge {
	node: Article!
	cursor: Cursor!
}

type ArticleConnection {
	edges: [ArticleEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type Draft {
	id: ID!
	author: Actor!

	contentType: ObjectType!
	title: String
	slug: String
	content: String!
	contentFormat: ContentFormat!

	status: DraftStatus!
	scheduledAt: Time
	objectId: ID

	autosaveVersion: Int!
	lastSavedAt: Time!

	createdAt: Time!
	updatedAt: Time!
}

type DraftEdge {
	node: Draft!
	cursor: Cursor!
}

type DraftConnection {
	edges: [DraftEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type Revision {
	id: ID!
	objectId: ID!
	version: Int!
	content: String!
	metadataJson: String
	changedBy: Actor!
	changeSummary: String
	changeType: ChangeType!
	createdAt: Time!
}

type RevisionEdge {
	node: Revision!
	cursor: Cursor!
}

type RevisionConnection {
	edges: [RevisionEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type Series {
	id: ID!
	author: Actor!

	title: String!
	description: String
	slug: String!
	coverImageUrl: String

	isComplete: Boolean!
	articleCount: Int!

	createdAt: Time!
	updatedAt: Time!
}

type SeriesEdge {
	node: Series!
	cursor: Cursor!
}

type SeriesConnection {
	edges: [SeriesEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type Category {
	id: ID!
	name: String!
	slug: String!
	description: String
	parent: Category
	children: [Category!]!

	articleCount: Int!
	order: Int!
	color: String

	createdAt: Time!
	updatedAt: Time!
}

type Publication {
	id: ID!
	name: String!
	tagline: String
	description: String
	slug: String!

	logoUrl: String
	bannerUrl: String
	customDomain: String

	actor: Actor!
	members: [PublicationMember!]!

	createdAt: Time!
	updatedAt: Time!
}

type PublicationMember {
	user: Actor!
	role: PublicationRole!
	displayName: String
	bio: String
	joinedAt: Time!
}

extend type Query {
	# Draft operations
	draft(id: ID!): Draft
	myDrafts(
		contentType: ObjectType
		status: DraftStatus
		first: Int
		after: Cursor
	): DraftConnection!

	# Revision history
	revisions(objectId: ID!, first: Int, after: Cursor): RevisionConnection!
	revision(objectId: ID!, version: Int!): Revision

	# Article queries
	article(id: ID!): Article
	articleBySlug(slug: String!): Article
	articles(
		authorId: ID
		seriesId: ID
		categoryId: ID
		first: Int
		after: Cursor
	): ArticleConnection!

	# Series
	series(id: ID!): Series
	seriesBySlug(slug: String!): Series
	allSeries(authorId: ID, first: Int, after: Cursor): SeriesConnection!

	# Categories
	category(id: ID!): Category
	categoryBySlug(slug: String!): Category
	categories(parentId: ID): [Category!]!
	rootCategories: [Category!]!

	# Publication
	publication(id: ID!): Publication
	publicationBySlug(slug: String!): Publication
	myPublications: [Publication!]!
}

extend type Mutation {
	# Draft lifecycle
	createDraft(input: CreateDraftInput!): Draft!
	updateDraft(id: ID!, input: UpdateDraftInput!): Draft!
	autosaveDraft(id: ID!, content: String!): Draft!
	deleteDraft(id: ID!): Boolean!

	# Publishing
	publishDraft(id: ID!): Article!
	scheduleDraft(id: ID!, scheduledAt: Time!): Draft!
	cancelScheduledDraft(id: ID!): Draft!

	# Article operations
	createArticle(input: CreateArticleInput!): Article!
	updateArticle(id: ID!, input: UpdateArticleInput!): Article!
	deleteArticle(id: ID!): Boolean!

	# Revision operations
	restoreRevision(objectId: ID!, version: Int!): Article!

	# Series management
	createSeries(input: CreateSeriesInput!): Series!
	updateSeries(id: ID!, input: UpdateSeriesInput!): Series!
	deleteSeries(id: ID!): Boolean!
	addArticleToSeries(seriesId: ID!, articleId: ID!, order: Int): Series!
	removeArticleFromSeries(seriesId: ID!, articleId: ID!): Series!
	reorderSeriesArticles(seriesId: ID!, articleIds: [ID!]!): Series!

	# Category management
	createCategory(input: CreateCategoryInput!): Category!
	updateCategory(id: ID!, input: UpdateCategoryInput!): Category!
	deleteCategory(id: ID!): Boolean!
	addArticleToCategory(categoryId: ID!, articleId: ID!): Article!
	removeArticleFromCategory(categoryId: ID!, articleId: ID!): Article!

	# Publication management
	createPublication(input: CreatePublicationInput!): Publication!
	updatePublication(id: ID!, input: UpdatePublicationInput!): Publication!
	invitePublicationMember(
		publicationId: ID!
		userId: ID!
		role: PublicationRole!
	): PublicationMember!
	removePublicationMember(publicationId: ID!, userId: ID!): Boolean!
	updatePublicationMemberRole(
		publicationId: ID!
		userId: ID!
		role: PublicationRole!
	): PublicationMember!
}

input CreateDraftInput {
	contentType: ObjectType! = ARTICLE
	title: String
	slug: String
	content: String!
	contentFormat: ContentFormat! = MARKDOWN
	objectId: ID
}

input UpdateDraftInput {
	title: String
	slug: String
	content: String
	contentFormat: ContentFormat
}

input CreateArticleInput {
	slug: String
	title: String!
	content: String!
	contentFormat: ContentFormat! = MARKDOWN

	subtitle: String
	excerpt: String
	featuredImageId: ID

	seriesId: ID
	seriesOrder: Int
	categoryIds: [ID!]

	seoTitle: String
	seoDescription: String
	canonicalUrl: String
	ogImage: String

	editorNotes: String
	reviewStatus: String
}

input UpdateArticleInput {
	slug: String
	title: String
	content: String
	contentFormat: ContentFormat

	subtitle: String
	excerpt: String
	featuredImageId: ID

	seriesId: ID
	seriesOrder: Int
	categoryIds: [ID!]

	seoTitle: String
	seoDescription: String
	canonicalUrl: String
	ogImage: String

	editorNotes: String
	reviewStatus: String
}

input CreateSeriesInput {
	slug: String
	title: String!
	description: String
	coverImageUrl: String
	isComplete: Boolean
}

input UpdateSeriesInput {
	title: String
	description: String
	coverImageUrl: String
	isComplete: Boolean
}

input CreateCategoryInput {
	slug: String
	name: String!
	description: String
	parentId: ID
	color: String
	order: Int
}

input UpdateCategoryInput {
	slug: String
	name: String
	description: String
	parentId: ID
	color: String
	order: Int
}

input CreatePublicationInput {
	slug: String
	name: String!
	tagline: String
	description: String
	logoId: ID
	bannerId: ID
	customDomain: String
}

input UpdatePublicationInput {
	slug: String
	name: String
	tagline: String
	description: String
	logoId: ID
	bannerId: ID
	customDomain: String
}

# Lesser GraphQL Schema - Phase 2 Federation Enhancements

# Cost Analytics Dashboard Types
type FederationCost {
	domain: String!
	ingressBytes: Int!
	egressBytes: Int!
	requestCount: Int!
	errorRate: Float!
	monthlyCostUSD: Float!
	healthScore: Float!
	recommendation: String
	lastUpdated: Time!
	breakdown: CostBreakdown!
}

type FederationCostConnection {
	edges: [FederationCostEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type FederationCostEdge {
	node: FederationCost!
	cursor: Cursor!
}

type InstanceHealthReport {
	domain: String!
	status: InstanceHealthStatus!
	metrics: InstanceHealthMetrics!
	issues: [HealthIssue!]!
	recommendations: [String!]!
	lastChecked: Time!
}

enum InstanceHealthStatus {
	HEALTHY
	WARNING
	CRITICAL
	OFFLINE
	UNKNOWN
}

type InstanceHealthMetrics {
	responseTime: Float!
	errorRate: Float!
	federationDelay: Float!
	queueDepth: Int!
	costEfficiency: Float!
}

type HealthIssue {
	type: String!
	severity: IssueSeverity!
	description: String!
	detectedAt: Time!
	impact: String!
}

enum IssueSeverity {
	LOW
	MEDIUM
	HIGH
	CRITICAL
}

# Media Streaming Integration Types
type MediaStream {
	id: ID!
	url: String!
	hlsPlaylistUrl: String
	dashManifestUrl: String
	thumbnailUrl: String!
	duration: Int!
	bitrates: [Bitrate!]!
	expiresAt: Time!
}

type Bitrate {
	quality: StreamQuality!
	bitsPerSecond: Int!
	width: Int!
	height: Int!
	codec: String!
}

enum StreamQuality {
	AUTO
	LOW # 480p
	MEDIUM # 720p
	HIGH # 1080p
	ULTRA # 4K
}

# Advanced Moderation Tools Types
type ModerationPattern {
	id: ID!
	pattern: String!
	type: PatternType!
	severity: ModerationSeverity!
	matchCount: Int!
	falsePositiveRate: Float!
	createdAt: Time!
	updatedAt: Time!
	createdBy: Actor!
	active: Boolean!
}

enum PatternType {
	REGEX
	KEYWORD
	PHRASE
	ML_PATTERN
}

enum ModerationSeverity {
	INFO
	LOW
	MEDIUM
	HIGH
	CRITICAL
}

type TrainingResult {
	success: Boolean!
	status: String! # SUBMITTED, IN_PROGRESS, COMPLETED, FAILED
	jobId: String! # Bedrock job ARN/ID
	jobName: String! # Human-readable job name
	datasetS3Key: String! # S3 key of training dataset
	modelVersion: String! # Model version (empty when SUBMITTED)
	accuracy: Float! # Training accuracy (0 when SUBMITTED)
	precision: Float! # Training precision (0 when SUBMITTED)
	recall: Float! # Training recall (0 when SUBMITTED)
	f1Score: Float! # Training F1 score (0 when SUBMITTED)
	samplesUsed: Int! # Number of training samples
	trainingTime: Int! # Training duration in seconds (0 when SUBMITTED)
	improvements: [String!]! # Improvements (empty when SUBMITTED)
}

type ModerationAlert {
	id: ID!
	severity: ModerationSeverity!
	pattern: ModerationPattern
	content: Object!
	matchedText: String!
	confidence: Float!
	suggestedAction: ModerationAction!
	timestamp: Time!
	handled: Boolean!
}

# Federation Management Types
type FederationLimit {
	domain: String!
	ingressLimitMB: Int!
	egressLimitMB: Int!
	requestsPerMinute: Int!
	monthlyBudgetUSD: Float
	active: Boolean!
	createdAt: Time!
	updatedAt: Time!
}

type FederationManagementStatus {
	domain: String!
	status: FederationState!
	reason: String
	pausedUntil: Time
	limits: FederationLimit
	metrics: FederationMetrics!
}

enum FederationState {
	ACTIVE
	PAUSED
	LIMITED
	BLOCKED
	ERROR
}

type FederationMetrics {
	currentMonthCostUSD: Float!
	currentMonthRequests: Int!
	currentMonthBandwidthMB: Int!
	averageResponseTime: Float!
	errorRate: Float!
}

type InstanceBudget {
	domain: String!
	monthlyBudgetUSD: Float!
	currentSpendUSD: Float!
	remainingBudgetUSD: Float!
	projectedOverspend: Float
	alertThreshold: Float!
	autoLimit: Boolean!
	period: String!
}

# Input Types for Phase 2
input ModerationPatternInput {
	pattern: String!
	type: PatternType!
	severity: ModerationSeverity!
	active: Boolean
}

input ModerationSampleInput {
	objectId: ID!
	objectType: String!
	label: String!
	confidence: Float!
}

input BedrockTrainingOptions {
	baseModelId: String
	datasetS3Path: String
	outputS3Path: String
	maxTrainingTime: Int
	earlyStoppingEnabled: Boolean
}

input FederationLimitInput {
	ingressLimitMB: Int
	egressLimitMB: Int
	requestsPerMinute: Int
	monthlyBudgetUSD: Float
}

# Phase 2 Query Extensions
extend type Query {
	# Cost Analytics
	federationCosts(first: Int, after: String, orderBy: CostOrderBy): FederationCostConnection!
	instanceHealthReport(domain: String!): InstanceHealthReport!
	costProjections(period: Period!): CostProjection!

	# Media Streaming
	mediaStreamUrl(mediaId: ID!): MediaStream!
	supportedBitrates(mediaId: ID!): [Bitrate!]!

	# Advanced Moderation
	moderationPatterns(
		active: Boolean
		severity: ModerationSeverity
		first: Int
		after: String
	): [ModerationPattern!]!
	moderationEffectiveness(patternId: ID!, period: ModerationPeriod!): ModerationEffectiveness!

	# Federation Management
	federationLimits(active: Boolean, first: Int, after: String): [FederationLimit!]!
	instanceBudgets(exceeded: Boolean): [InstanceBudget!]!
	federationHealth(threshold: Float): [FederationManagementStatus!]!
}

# Phase 2 Mutation Extensions
extend type Mutation {
	# Media Streaming
	requestStreamingUrl(mediaId: ID!, quality: StreamQuality): MediaStream!
	preloadMedia(mediaIds: [ID!]!): [MediaStream!]!

	# Advanced Moderation
	createModerationPattern(input: ModerationPatternInput!): ModerationPattern!
	updateModerationPattern(id: ID!, input: ModerationPatternInput!): ModerationPattern!
	deleteModerationPattern(id: ID!): Boolean!
	trainModerationModel(
		samples: [ModerationSampleInput!]!
		options: BedrockTrainingOptions
	): TrainingResult!

	# Federation Management
	setFederationLimit(domain: String!, limit: FederationLimitInput!): FederationLimit!
	pauseFederation(domain: String!, reason: String!, until: Time): FederationManagementStatus!
	resumeFederation(domain: String!): FederationManagementStatus!
	setInstanceBudget(domain: String!, monthlyUSD: Float!, autoLimit: Boolean): InstanceBudget!

	# Cost Management
	optimizeFederationCosts(threshold: Float!): CostOptimizationResult!
}

# Phase 2 Subscription Extensions
extend type Subscription {
	# Moderation Alerts
	moderationAlerts(severity: ModerationSeverity): ModerationAlert!

	# Cost Alerts
	costAlerts(thresholdUSD: Float!): CostAlert!
	budgetAlerts(domain: String): BudgetAlert!

	# Federation Health
	federationHealthUpdates(domain: String): FederationHealthUpdate!
}

# Additional Phase 2 Types
type CostProjection {
	period: Period!
	currentCost: Float!
	projectedCost: Float!
	variance: Float!
	topDrivers: [Driver!]!
	recommendations: [String!]!
}

type Driver {
	type: String!
	domain: String
	cost: Float!
	percentOfTotal: Float!
	trend: Trend!
}

enum Trend {
	INCREASING
	STABLE
	DECREASING
}

type ModerationEffectiveness {
	patternId: ID!
	matchCount: Int!
	truePositives: Int!
	falsePositives: Int!
	missedCount: Int!
	precision: Float!
	recall: Float!
	f1Score: Float!
}

type CostOptimizationResult {
	optimized: Int!
	savedMonthlyUSD: Float!
	actions: [OptimizationAction!]!
}

type OptimizationAction {
	domain: String!
	action: String!
	savingsUSD: Float!
	impact: String!
}

type CostAlert {
	id: ID!
	type: String!
	amount: Float!
	threshold: Float!
	domain: String
	message: String!
	timestamp: Time!
}

type BudgetAlert {
	id: ID!
	domain: String!
	budgetUSD: Float!
	spentUSD: Float!
	percentUsed: Float!
	projectedOverspend: Float
	alertLevel: AlertLevel!
	timestamp: Time!
}

enum AlertLevel {
	INFO
	WARNING
	CRITICAL
}

type FederationHealthUpdate {
	domain: String!
	previousStatus: InstanceHealthStatus!
	currentStatus: InstanceHealthStatus!
	issues: [HealthIssue!]!
	timestamp: Time!
}

enum CostOrderBy {
	TOTAL_COST_DESC
	TOTAL_COST_ASC
	ERROR_RATE_DESC
	REQUEST_COUNT_DESC
	DOMAIN_ASC
}

enum ModerationPeriod {
	HOURLY
	DAILY
	WEEKLY
	MONTHLY
}
# Lesser GraphQL Schema - Phase 3 Federation Visualization

# Federation Relationship Visualization Types
type FederationGraph {
	nodes: [InstanceNode!]!
	edges: [FederationEdge!]!
	clusters: [InstanceCluster!]!
	healthScore: Float!
}

type InstanceNode {
	domain: String!
	displayName: String!
	software: String!
	version: String!
	userCount: Int!
	statusCount: Int!
	federatingWith: Int!
	healthStatus: InstanceHealthStatus!
	coordinates: Coordinates!
	metadata: InstanceMetadata!
}

type Coordinates {
	x: Float!
	y: Float!
}

type InstanceMetadata {
	firstSeen: Time!
	lastActivity: Time!
	monthlyActiveUsers: Int!
	registrationsOpen: Boolean!
	approvalRequired: Boolean!
	primaryLanguage: String!
	description: String
}

type FederationEdge {
	source: String!
	target: String!
	weight: Float!
	volumePerDay: Int!
	errorRate: Float!
	latency: Float!
	bidirectional: Boolean!
	healthScore: Float!
}

type InstanceCluster {
	id: ID!
	name: String!
	members: [String!]!
	commonality: String!
	avgHealthScore: Float!
	totalVolume: Int!
	description: String!
}

type InstanceRelations {
	domain: String!
	directConnections: [InstanceConnection!]!
	indirectConnections: [InstanceConnection!]!
	blockedBy: [String!]!
	blocking: [String!]!
	federationScore: Float!
	recommendations: [FederationRecommendation!]!
}

type InstanceConnection {
	domain: String!
	connectionType: ConnectionType!
	strength: Float!
	volumeIn: Int!
	volumeOut: Int!
	sharedUsers: Int!
	lastActivity: Time!
}

enum ConnectionType {
	FOLLOWS
	MENTIONS
	REPLIES
	BOOSTS
	QUOTES
	MIXED
}

type FederationRecommendation {
	type: RecommendationType!
	priority: Priority!
	domain: String
	reason: String!
	potentialImpact: String!
	action: String!
}

enum RecommendationType {
	PERFORMANCE
	COST
	SECURITY
	CONNECTIVITY
	CONTENT
}

enum Priority {
	LOW
	MEDIUM
	HIGH
	CRITICAL
}

type FederationFlow {
	topSources: [FlowNode!]!
	topDestinations: [FlowNode!]!
	volumeByHour: [HourlyVolume!]!
	costByInstance: [InstanceCost!]!
}

type FlowNode {
	domain: String!
	volume: Int!
	percentage: Float!
	trend: Trend!
	avgMessageSize: Int!
}

type HourlyVolume {
	hour: Time!
	inbound: Int!
	outbound: Int!
	errors: Int!
	avgLatency: Float!
}

type InstanceCost {
	domain: String!
	costUSD: Float!
	percentage: Float!
	breakdown: CostBreakdown!
}

# Streaming Analytics Types
type StreamingAnalytics {
	totalViews: Int!
	uniqueViewers: Int!
	averageWatchTime: Duration!
	qualityDistribution: [QualityStats!]!
	bufferingEvents: Int!
	completionRate: Float!
}

type QualityStats {
	quality: StreamQuality!
	viewCount: Int!
	percentage: Float!
	avgBandwidth: Float!
}

scalar Duration

type StreamConnection {
	edges: [StreamEdge!]!
	pageInfo: PageInfo!
	totalCount: Int!
}

type StreamEdge {
	node: Stream!
	cursor: Cursor!
}

type Stream {
	id: ID!
	mediaId: ID!
	title: String!
	thumbnail: String!
	duration: Duration!
	viewCount: Int!
	quality: StreamQuality!
	popularity: Float!
	createdAt: Time!
}

type BandwidthReport {
	period: TimePeriod!
	totalGB: Float!
	peakMbps: Float!
	avgMbps: Float!
	byQuality: [QualityBandwidth!]!
	byHour: [HourlyBandwidth!]!
	cost: Float!
}

type QualityBandwidth {
	quality: StreamQuality!
	totalGB: Float!
	percentage: Float!
}

type HourlyBandwidth {
	hour: Time!
	totalGB: Float!
	peakMbps: Float!
}

enum TimePeriod {
	HOUR
	DAY
	WEEK
	MONTH
}

# Moderation Dashboard Types
type ModerationDashboard {
	pendingReviews: Int!
	recentDecisions: [ModerationDecision!]!
	topPatterns: [PatternStats!]!
	falsePositiveRate: Float!
	averageResponseTime: Duration!
	threatTrends: [ThreatTrend!]!
}

type PatternStats {
	pattern: ModerationPattern!
	matchCount: Int!
	accuracy: Float!
	lastMatch: Time!
	trend: Trend!
}

type ThreatTrend {
	type: String!
	severity: ModerationSeverity!
	count: Int!
	change: Float!
	instances: [String!]!
}

type ModeratorStats {
	moderatorId: ID!
	period: TimePeriod!
	decisionsCount: Int!
	avgResponseTime: Duration!
	accuracy: Float!
	overturned: Int!
	categories: [CategoryStats!]!
}

type CategoryStats {
	category: String!
	count: Int!
	accuracy: Float!
}

type ModerationItem {
	id: ID!
	content: Object!
	reportCount: Int!
	severity: ModerationSeverity!
	priority: Priority!
	assignedTo: Actor
	deadline: Time!
}

type ThreatAlert {
	id: ID!
	type: String!
	severity: ModerationSeverity!
	source: String!
	description: String!
	affectedInstances: [String!]!
	mitigationSteps: [String!]!
	timestamp: Time!
}

# Performance Monitoring Types
type PerformanceReport {
	service: ServiceCategory!
	p50Latency: Duration!
	p95Latency: Duration!
	p99Latency: Duration!
	errorRate: Float!
	throughput: Float!
	coldStarts: Int!
	period: TimePeriod!
}

enum ServiceCategory {
	GRAPHQL_API
	FEDERATION_DELIVERY
	MEDIA_PROCESSOR
	MODERATION_ENGINE
	SEARCH_INDEXER
	STREAMING_SERVICE
}

type QueryPerformance {
	query: String!
	count: Int!
	avgDuration: Duration!
	p95Duration: Duration!
	errorCount: Int!
	lastSeen: Time!
}

type InfrastructureStatus {
	healthy: Boolean!
	services: [ServiceStatus!]!
	databases: [DatabaseStatus!]!
	queues: [QueueStatus!]!
	alerts: [InfrastructureAlert!]!
}

type ServiceStatus {
	name: String!
	type: ServiceCategory!
	status: HealthStatus!
	uptime: Float!
	lastRestart: Time
	errorRate: Float!
}

enum HealthStatus {
	HEALTHY
	DEGRADED
	DOWN
	UNKNOWN
}

type DatabaseStatus {
	name: String!
	type: String!
	status: HealthStatus!
	connections: Int!
	latency: Duration!
	throughput: Float!
}

type QueueStatus {
	name: String!
	depth: Int!
	processingRate: Float!
	oldestMessage: Time
	dlqCount: Int!
}

type InfrastructureAlert {
	id: ID!
	service: String!
	severity: AlertSeverity!
	message: String!
	timestamp: Time!
	resolved: Boolean!
}

type PerformanceAlert {
	id: ID!
	service: ServiceCategory!
	metric: String!
	threshold: Float!
	actualValue: Float!
	severity: AlertSeverity!
	timestamp: Time!
}

type InfrastructureEvent {
	id: ID!
	type: InfrastructureEventType!
	service: String!
	description: String!
	impact: String!
	timestamp: Time!
}

enum InfrastructureEventType {
	DEPLOYMENT
	SCALING
	FAILURE
	RECOVERY
	MAINTENANCE
}

enum AlertSeverity {
	INFO
	WARNING
	ERROR
	CRITICAL
}

# Input Types
input StreamingQualityInput {
	mediaId: ID!
	quality: StreamQuality!
	bufferingEvents: Int!
	watchTime: Int!
}

input StreamingPreferencesInput {
	defaultQuality: StreamQuality
	autoQuality: Boolean
	preloadNext: Boolean
	dataSaver: Boolean
}

input ReblogFilterInput {
	key: String!
	enabled: Boolean!
}

input UpdateUserPreferencesInput {
	language: String
	defaultPostingVisibility: Visibility
	defaultMediaSensitive: Boolean
	expandSpoilers: Boolean
	expandMedia: ExpandMediaPreference
	autoplayGifs: Boolean
	showFollowCounts: Boolean
	preferredTimelineOrder: TimelineOrder
	searchSuggestionsEnabled: Boolean
	personalizedSearchEnabled: Boolean
	reblogFilters: [ReblogFilterInput!]
	streaming: StreamingPreferencesInput
}

input ModerationFilter {
	severity: ModerationSeverity
	assignedTo: ID
	priority: Priority
	unhandled: Boolean
}

# Phase 3 Query Extensions
extend type Query {
	# Federation Visualization
	federationMap(depth: Int = 2): FederationGraph!
	instanceRelationships(domain: String!): InstanceRelations!
	federationFlow(period: TimePeriod!): FederationFlow!

	# Streaming Analytics
	streamingAnalytics(mediaId: ID!): StreamingAnalytics!
	popularStreams(first: Int!, after: String): StreamConnection!
	bandwidthUsage(period: TimePeriod!): BandwidthReport!

	# Moderation Dashboard
	moderationDashboard(filter: ModerationFilter): ModerationDashboard!
	patternEffectiveness(patternId: ID!): PatternStats!
	moderatorActivity(moderatorId: ID!, period: TimePeriod!): ModeratorStats!

	# Performance Monitoring
	performanceMetrics(service: ServiceCategory!): PerformanceReport!
	slowQueries(threshold: Duration!): [QueryPerformance!]!
	infrastructureHealth: InfrastructureStatus!

	# Admin parity
	adminAccounts(first: Int = 50, after: Cursor): AdminAccountConnection!
	adminAccount(id: ID!): AdminAccount
	adminDomainAllows(first: Int = 100, after: Cursor): AdminDomainAllowConnection!
	adminDomainBlocks(first: Int = 100, after: Cursor): AdminDomainBlockConnection!
	adminDomainBlock(id: ID!): AdminDomainBlock
	adminEmailDomainBlocks(first: Int = 100, after: Cursor): AdminEmailDomainBlockConnection!
	adminFederationInstances(first: Int = 100, after: Cursor): AdminFederationInstanceConnection!
	adminFederationInstance(domain: String!): AdminFederationInstance!
	adminFederationStatistics(start: Time, end: Time): AdminFederationStatistics!
	adminModerationEvents(
		filter: AdminModerationEventFilter
		first: Int = 50
		after: Cursor
	): AdminModerationEventConnection!
	adminModerationReviewers: [AdminReviewer!]!
	adminTrustGraph(limit: Int = 100): AdminTrustGraph!
	adminReports(
		status: AdminReportStatus = OPEN
		first: Int = 50
		after: Cursor
	): AdminReportConnection!
	adminReport(id: ID!): AdminReport
	adminStatuses(filter: AdminStatusFilter, first: Int = 20, after: Cursor): AdminStatusConnection!
	adminStatus(id: ID!): Object
}

# Phase 3 Mutation Extensions
extend type Mutation {
	# Streaming Quality
	reportStreamingQuality(input: StreamingQualityInput!): StreamingQualityReport!

	# Admin parity
	adminCreateUser(input: AdminCreateUserInput!): AdminAccount!
	adminAccountAction(input: AdminAccountActionInput!): Boolean!
	adminCreateAnnouncement(input: AdminCreateAnnouncementInput!): Announcement!
	adminCreateDomainAllow(domain: String!): AdminDomainAllow!
	adminDeleteDomainAllow(id: ID!): Boolean!
	adminCreateDomainBlock(input: AdminDomainBlockCreateInput!): AdminDomainBlock!
	adminUpdateDomainBlock(id: ID!, input: AdminDomainBlockUpdateInput!): AdminDomainBlock!
	adminDeleteDomainBlock(id: ID!): Boolean!
	adminCreateEmailDomainBlock(domain: String!): AdminEmailDomainBlock!
	adminDeleteEmailDomainBlock(id: ID!): Boolean!
	adminOverrideModerationEvent(
		input: AdminModerationEventOverrideInput!
	): AdminModerationEventOverrideResult!
	adminUpdateTrust(input: AdminUpdateTrustInput!): AdminUpdateTrustResult!
	adminPromoteReviewer(id: ID!): AdminReviewerRoleResult!
	adminDemoteReviewer(id: ID!): AdminReviewerRoleResult!
	adminReportAction(id: ID!, action: AdminReportAction!): AdminReport!
	adminDeleteStatus(id: ID!): Boolean!
	adminSetStatusSensitive(id: ID!, sensitive: Boolean!): Object!
}

# Phase 3 Subscription Extensions
extend type Subscription {
	# Moderation Queue
	moderationQueueUpdate(priority: Priority): ModerationItem!
	threatIntelligence: ThreatAlert!

	# Performance Alerts
	performanceAlert(severity: AlertSeverity!): PerformanceAlert!
	infrastructureEvent: InfrastructureEvent!
}

# Additional Types
type StreamingQualityReport {
	success: Boolean!
	mediaId: ID!
	quality: StreamQuality!
	reportId: ID!
}

type UserPreferences {
	actorId: ID!
	posting: PostingPreferences!
	reading: ReadingPreferences!
	discovery: DiscoveryPreferences!
	streaming: StreamingPreferences!
	notifications: NotificationPreferences!
	privacy: PrivacyPreferences!
	reblogFilters: [ReblogFilter!]!
}

type PostingPreferences {
	defaultVisibility: Visibility!
	defaultSensitive: Boolean!
	defaultLanguage: String!
}

type ReadingPreferences {
	expandSpoilers: Boolean!
	expandMedia: ExpandMediaPreference!
	autoplayGifs: Boolean!
	timelineOrder: TimelineOrder!
}

type DiscoveryPreferences {
	showFollowCounts: Boolean!
	searchSuggestionsEnabled: Boolean!
	personalizedSearchEnabled: Boolean!
}

type StreamingPreferences {
	defaultQuality: StreamQuality!
	autoQuality: Boolean!
	preloadNext: Boolean!
	dataSaver: Boolean!
}

type NotificationPreferences {
	email: Boolean! # Always false - Email notifications are not supported by Lesser
	push: Boolean!
	inApp: Boolean!
	digest: DigestFrequency!
}

enum DigestFrequency {
	NEVER
	DAILY
	WEEKLY
	MONTHLY
}

type PrivacyPreferences {
	defaultVisibility: Visibility!
	indexable: Boolean!
	showOnlineStatus: Boolean!
}

type ReblogFilter {
	key: String!
	enabled: Boolean!
}

enum ExpandMediaPreference {
	DEFAULT
	SHOW_ALL
	HIDE_ALL
}

enum TimelineOrder {
	NEWEST
	OLDEST
}

#
# Phase 3 Admin Parity Types
#

type AdminIP {
	ip: String!
	usedAt: Time!
}

type AdminRole {
	id: ID!
	name: String!
	permissions: Int!
}

type AdminAccount {
	id: ID!
	username: String!
	createdAt: Time!
	locale: String!
	ip: String
	ips: [AdminIP!]!
	role: AdminRole!
	confirmed: Boolean!
	approved: Boolean!
	disabled: Boolean!
	silenced: Boolean!
	suspended: Boolean!
	actor: Actor
	reportsCount: Int!
	resolvedReportsCount: Int!
}

type AdminAccountConnection {
	accounts: [AdminAccount!]!
	nextCursor: Cursor
}

input AdminCreateUserInput {
	username: String!
	email: String
	"""
	Deprecated: Lesser is passwordless; this field is ignored if provided.
	"""
	password: String
	displayName: String
	role: String
}

input AdminAccountActionInput {
	id: ID!
	type: String!
	text: String
}

input AdminCreateAnnouncementInput {
	text: String!
	allDay: Boolean
	startsAt: Time
	endsAt: Time
}

type AdminDomainAllow {
	id: ID!
	domain: String!
	createdAt: Time!
}

type AdminDomainAllowConnection {
	allows: [AdminDomainAllow!]!
	nextCursor: Cursor
}

type AdminDomainBlock {
	id: ID!
	domain: String!
	severity: String!
	rejectMedia: Boolean!
	rejectReports: Boolean!
	privateComment: String
	publicComment: String
	obfuscate: Boolean!
	createdAt: Time!
	updatedAt: Time!
}

type AdminDomainBlockConnection {
	blocks: [AdminDomainBlock!]!
	nextCursor: Cursor
}

input AdminDomainBlockCreateInput {
	domain: String!
	severity: String
	rejectMedia: Boolean
	rejectReports: Boolean
	privateComment: String
	publicComment: String
	obfuscate: Boolean
}

input AdminDomainBlockUpdateInput {
	severity: String
	rejectMedia: Boolean
	rejectReports: Boolean
	privateComment: String
	publicComment: String
	obfuscate: Boolean
}

type AdminEmailDomainBlock {
	id: ID!
	domain: String!
	createdAt: Time!
}

type AdminEmailDomainBlockConnection {
	blocks: [AdminEmailDomainBlock!]!
	nextCursor: Cursor
}

type AdminFederationInstanceInfo {
	domain: String!
	software: String
	version: String
	activeUsers: Int!
	totalMessages: Int!
	trustScore: Float!
	firstSeen: Time!
	lastSeen: Time!
	isSilenced: Boolean!
	isSuspended: Boolean!
}

type AdminFederationInstanceConnection {
	instances: [AdminFederationInstanceInfo!]!
	nextCursor: Cursor
}

type AdminFederationInstance {
	instance: AdminFederationInstanceInfo!
	detailsJSON: String
}

type AdminFederationStatisticsTimeRange {
	start: Time!
	end: Time!
}

type AdminFederationStatistics {
	activeInstances: Int!
	totalMessages: Int!
	totalUsers: Int!
	timeRange: AdminFederationStatisticsTimeRange!
}

input AdminModerationEventFilter {
	eventType: String
	category: String
	minSeverity: Int
	actorId: ID
	objectId: ID
}

type AdminModerationEvent {
	id: ID!
	eventType: String!
	actorId: ID!
	objectId: ID!
	objectType: String!
	category: String!
	severity: String!
	reason: String
	evidenceJSON: String
	confidenceScore: Float!
	createdAt: Time!
}

type AdminModerationEventConnection {
	events: [AdminModerationEvent!]!
	nextCursor: Cursor
}

input AdminModerationEventOverrideInput {
	eventId: ID!
	decision: String!
	reason: String
}

type AdminModerationEventOverrideResult {
	eventId: ID!
	decision: String!
	action: String!
	override: Boolean!
	admin: String!
	reason: String
}

type AdminTrustGraphNode {
	id: ID!
	type: String!
}

type AdminTrustGraphEdge {
	from: ID!
	to: ID!
	trust: Float!
	createdAt: Time!
	updatedAt: Time!
}

type AdminTrustGraphStats {
	totalNodes: Int!
	totalEdges: Int!
}

type AdminTrustGraph {
	nodes: [AdminTrustGraphNode!]!
	edges: [AdminTrustGraphEdge!]!
	stats: AdminTrustGraphStats!
}

input AdminUpdateTrustInput {
	fromActorId: ID!
	toActorId: ID!
	trust: Float!
	category: String
	reason: String
}

type AdminUpdateTrustResult {
	fromActorId: ID!
	toActorId: ID!
	trust: Float!
	category: String!
	updatedBy: String!
	reason: String
	updatedAt: Time!
}

type AdminReviewer {
	id: ID!
	username: String!
	role: String!
	totalReviews: Int!
	accurateReviews: Int!
	accuracyRate: Float!
	lastReviewAt: Time
}

type AdminReviewerRoleResult {
	userId: ID!
	username: String!
	newRole: String!
	updatedBy: String!
}

enum AdminReportStatus {
	OPEN
	RESOLVED
	REJECTED
}

enum AdminReportAction {
	ASSIGN_TO_SELF
	UNASSIGN
	RESOLVE
	REOPEN
}

type AdminReport {
	id: ID!
	actionTaken: Boolean!
	actionTakenAt: Time
	category: String!
	comment: String
	forwarded: Boolean!
	createdAt: Time!
	updatedAt: Time!
	reporter: Actor!
	target: Actor!
	assignedAccount: Actor
	actionTakenBy: Actor
	statuses: [Object!]!
}

type AdminReportConnection {
	reports: [AdminReport!]!
	nextCursor: Cursor
}

input AdminStatusFilter {
	local: Boolean
	remote: Boolean
	byDomain: String
	visibility: String
	flagged: Boolean
	reported: Boolean
	media: Boolean
	sensitive: Boolean
	minDate: Time
	maxDate: Time
}

type AdminStatusConnection {
	statuses: [Object!]!
	nextCursor: Cursor
}
