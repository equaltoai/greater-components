# _patterns.yaml - Machine-readable patterns for Greater Components
# Documents correct and incorrect usage patterns for AI training

patterns:
  styled_components:
    name: 'Using Styled Primitives'
    problem: 'Need ready-to-use UI components with consistent styling'
    solution: 'Import and use styled components from primitives package'
    correct_example: |
      <script>
        // CORRECT: Import styled components for quick development
        // Provides consistent styling, accessibility, and theming support
        import { Button, Modal } from '@equaltoai/greater-components/primitives';
        import { SettingsIcon } from '@equaltoai/greater-components/icons';
        
        let showSettings = $state(false);
      </script>

      <Button 
        variant="solid" 
        size="md"
        onclick={() => showSettings = true}
      >
        {#snippet prefix()}<SettingsIcon />{/snippet}
        Open Settings
      </Button>

      <Modal 
        bind:open={showSettings} 
        title="Settings" 
        size="lg"
      >
        <p>Your settings content here</p>
        
        {#snippet footer()}
          <Button variant="ghost" onclick={() => showSettings = false}>
            Cancel
          </Button>
          <Button variant="solid">Save</Button>
        {/snippet}
      </Modal>
    anti_patterns:
      - name: 'Manual DOM Manipulation'
        why: 'Bypasses Svelte reactivity and breaks accessibility features'
        incorrect_example: |
          // INCORRECT: Don't manipulate DOM directly
          // Breaks Svelte reactivity and accessibility features
          function openSettings() {
            document.getElementById('modal').style.display = 'block';
            document.getElementById('overlay').classList.add('visible');
          }
        consequences:
          - breaks_svelte_reactivity
          - loses_accessibility_features
          - no_focus_management
          - difficult_to_maintain
      - name: 'Mixing UI Libraries'
        why: 'Creates inconsistent UX and increases bundle size'
        incorrect_example: |
          // INCORRECT: Don't mix different UI libraries
          // Creates style conflicts and inconsistent UX
          import { Button } from '@equaltoai/greater-components/primitives';
          import { Modal } from 'some-other-ui-library';

          // Style conflicts and inconsistent theming
        consequences:
          - style_conflicts
          - inconsistent_theming
          - larger_bundle_size
          - maintenance_complexity

  headless_components:
    name: 'Using Headless Primitives'
    problem: 'Need complete control over styling with existing design system'
    solution: 'Use headless components that provide behavior without styling'
    correct_example: |
      <script>
        // CORRECT: Use headless components for styling flexibility
        // Provides behavior, accessibility, and keyboard navigation without styling opinions
        import { createButton } from '@equaltoai/greater-components/headless/button';
        
        const button = createButton({
          type: 'button',
          loading: false,
          onClick: () => console.log('Clicked!')
        });
      </script>

      <!-- Apply your own styling completely -->
      <button 
        use:button.actions.button
        class="my-custom-button"
      >
        {#if button.state.loading}
          <span class="spinner"></span>
        {:else}
          Click Me
        {/if}
      </button>

      <style>
        .my-custom-button {
          /* Your design system styles */
          padding: 1rem 2rem;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border: none;
          border-radius: 0.5rem;
        }
      </style>
    anti_patterns:
      - name: 'Fighting Styled Component Styles'
        why: 'If you need to override everything, use headless instead'
        incorrect_example: |
          // INCORRECT: Don't fight against styled component CSS
          // If overriding everything, use headless components instead
          <script>
            import { Button } from '@equaltoai/greater-components/primitives';
          </script>

          <Button class="my-override" variant="solid">Click</Button>

          <style>
            /* Overriding everything defeats the purpose */
            :global(.my-override) {
              all: unset !important;
              /* Custom styles... */
            }
          </style>
        consequences:
          - specificity_wars
          - fragile_overrides
          - breaks_on_updates
          - unnecessary_bundle_weight

  theming_customization:
    name: 'Customizing Theme with Design Tokens'
    problem: 'Need to apply custom branding to components'
    solution: 'Override CSS custom properties for design tokens'
    correct_example: |
      <script>
        // CORRECT: Override design tokens for custom branding
        // Changes apply globally without component modifications
        import { ThemeProvider } from '@equaltoai/greater-components/primitives';
      </script>

      <ThemeProvider>
        <slot />
      </ThemeProvider>

      <style>
        :global(:root) {
          /* Brand colors */
          --gr-color-primary-600: #8b5cf6;
          --gr-color-primary-700: #7c3aed;
          
          /* Typography */
          --gr-typography-fontFamily-sans: 'Inter', system-ui, sans-serif;
          
          /* Spacing adjustments */
          --gr-spacing-md: 1rem;
          
          /* Border radius */
          --gr-radii-lg: 12px;
        }
      </style>
    anti_patterns:
      - name: 'Modifying Source Component Styles'
        why: 'Changes lost on updates and breaks other instances'
        incorrect_example: |
          // INCORRECT: Don't modify component library source files
          // Changes are lost when updating packages

          // In node_modules/@equaltoai/greater-components/primitives/Button.svelte
          <style>
            .button {
              background: #my-custom-color; /* Don't do this! */
            }
          </style>
        consequences:
          - changes_lost_on_update
          - affects_all_button_instances
          - breaks_version_control
          - maintenance_nightmare

  lesser_graphql_integration:
    name: 'Integrating with Lesser via GraphQL'
    problem: 'Need type-safe Lesser integration with advanced features'
    solution: 'Use LesserGraphQLAdapter with GraphQL-backed timeline components'
    correct_example: |
      <script>
        // CORRECT: Use LesserGraphQLAdapter for type-safe integration
        // Provides full TypeScript support and advanced Lesser features
        import { LesserGraphQLAdapter } from '@equaltoai/greater-components/adapters';
        import { TimelineVirtualizedReactive } from '@equaltoai/greater-components/faces/social';
        
        const adapter = new LesserGraphQLAdapter({
          httpEndpoint: 'https://my-instance.social/graphql',
          token: import.meta.env.VITE_LESSER_TOKEN,
        });
        
        const view = { type: 'home' };
      </script>

      <TimelineVirtualizedReactive {adapter} {view} estimateSize={320} />
    anti_patterns:
      - name: 'Hardcoding API Tokens'
        why: 'Security risk and prevents environment-based configuration'
        incorrect_example: |
          // INCORRECT: Never hardcode authentication tokens
          // Tokens exposed in source code and version control
          const adapter = new LesserGraphQLAdapter({
            httpEndpoint: 'https://my-instance.social/graphql',
            token: 'sk_live_abc123xyz789' // SECURITY RISK!
          });
        consequences:
          - security_breach_risk
          - tokens_in_version_control
          - cannot_rotate_credentials
          - exposed_in_client_bundles

  mastodon_rest_integration:
    name: 'Integrating with Mastodon via REST API'
    problem: 'Need to connect to standard Mastodon instances'
    solution: 'Use your REST client and map payloads with MastodonAdapter'
    correct_example: |
      <script lang="ts">
        import {
          MastodonAdapter,
          type MastodonStatus,
          Status,
        } from '@equaltoai/greater-components/faces/social';

        const mapper = new MastodonAdapter();
        let items = $state([]);

        $effect(() => {
          void (async () => {
            const response = await fetch(
              'https://mastodon.social/api/v1/timelines/public?local=true'
            );
            const payload = (await response.json()) as MastodonStatus[];
            items = payload.map((status) => mapper.toGeneric(status));
          })();
        });
      </script>

      {#each items as status (status.id)}
        <Status.Root {status}>
          <Status.Header />
          <Status.Content />
          <Status.Media />
          <Status.Actions />
        </Status.Root>
      {/each}
    anti_patterns:
      - name: 'Using the wrong server API'
        why: 'Lesser-only features require the Lesser GraphQL API'
        incorrect_example: |
          // INCORRECT: Mastodon REST endpoints won't provide Lesser-only fields
          const response = await fetch('https://lesser-instance.social/api/v1/timelines/home');
          // For Lesser-specific features, use LesserGraphQLAdapter against /graphql instead.
        consequences:
          - missing_advanced_features
          - incomplete_data
          - poor_user_experience

  virtual_scrolling_timelines:
    name: 'Implementing Virtual Scrolling for Large Timelines'
    problem: 'Timeline with thousands of posts causes performance issues'
    solution: 'Use TimelineVirtualizedReactive (TanStack Virtual built-in)'
    correct_example: |
      <script>
        // CORRECT: Virtualization happens inside the component
        import { TimelineVirtualizedReactive } from '@equaltoai/greater-components/faces/social';
      </script>

      <div style="height: 100vh;">
        <TimelineVirtualizedReactive {items} estimateSize={320} overscan={8} />
      </div>
    anti_patterns:
      - name: 'Rendering All Items'
        why: 'Rendering thousands of DOM nodes causes browser freeze'
        incorrect_example: |
          // INCORRECT: Don't render all timeline items at once
          // Causes severe performance issues with large timelines
          {#each items as status}
            <!-- Renders 1000+ status cards = browser freeze -->
            <StatusCard {status} />
          {/each}
        consequences:
          - browser_freeze_with_large_lists
          - high_memory_usage
          - slow_initial_render
          - poor_scroll_performance

  accessibility_keyboard_navigation:
    name: 'Ensuring Keyboard Navigation'
    problem: 'Components must be fully keyboard accessible'
    solution: 'Components include built-in keyboard support, test thoroughly'
    correct_example: |
      <script>
        // CORRECT: Components handle keyboard navigation automatically
        // Test with keyboard-only usage
        import { Menu } from '@equaltoai/greater-components/primitives';
        
        let menuItems = [
          { label: 'Edit', action: () => console.log('edit') },
          { label: 'Delete', action: () => console.log('delete') }
        ];
      </script>

      <!-- Keyboard support built-in:
           - Tab to focus trigger
           - Enter/Space to open
           - Arrow keys to navigate
           - Enter to select
           - Escape to close
      -->
      <Menu.Root>
        <Menu.Trigger>Actions</Menu.Trigger>
        <Menu.Items>
          {#each menuItems as item}
            <Menu.Item onclick={item.action}>
              {item.label}
            </Menu.Item>
          {/each}
        </Menu.Items>
      </Menu.Root>
    anti_patterns:
      - name: 'Using Non-Interactive Elements for Actions'
        why: "Divs and spans aren't keyboard accessible or screen reader friendly"
        incorrect_example: |
          // INCORRECT: Don't use non-interactive elements for actions
          // Not keyboard accessible or screen reader friendly
          <div 
            onclick={handleClick}
            class="fake-button"
          >
            Click Me
          </div>

          <!-- Missing:
               - Keyboard support (no Enter/Space)
               - Focus indicator
               - Screen reader semantics
               - Disabled state handling
          -->
        consequences:
          - not_keyboard_accessible
          - screen_readers_confused
          - violates_wcag_guidelines
          - poor_accessibility_score

  component_composition:
    name: 'Composing Components with Snippets'
    problem: 'Need to customize component parts without breaking structure'
    solution: 'Use Svelte 5 snippets for flexible composition'
    correct_example: |
      <script>
        // CORRECT: Use snippets for flexible component composition
        // Svelte 5 pattern for customizable component parts
        import { Button, Modal } from '@equaltoai/greater-components/primitives';
        import { SaveIcon, TrashIcon } from '@equaltoai/greater-components/icons';
      </script>

      <Modal open={true} title="Confirm Action">
        <!-- Custom modal content -->
        <p>Are you sure you want to delete this item?</p>
        
        {#snippet footer()}
          <!-- Custom footer with icons -->
          <Button variant="ghost">
            Cancel
          </Button>
          <Button variant="danger">
            {#snippet prefix()}<TrashIcon />{/snippet}
            Delete
          </Button>
        {/snippet}
      </Modal>
    anti_patterns:
      - name: 'Trying to Use Slots'
        why: 'Svelte 5 uses snippets, not legacy slots pattern'
        incorrect_example: |
          // INCORRECT: Don't use old Svelte 4 slot syntax
          // Greater Components uses Svelte 5 snippets, not slots
          <Modal open={true} title="Confirm">
            <p slot="body">Content here</p>
            <div slot="footer">
              <Button>OK</Button>
            </div>
          </Modal>
        consequences:
          - does_not_work_in_svelte_5
          - snippets_are_the_new_pattern
          - compilation_errors

  error_handling:
    name: 'Handling Adapter Errors Gracefully'
    problem: 'Network errors and API failures must be handled properly'
    solution: 'Use try-catch with user-friendly error messages'
    correct_example: |
      <script>
        // CORRECT: Handle errors gracefully with user feedback
        // Provides loading states and error messages
        import { createTimelineStore } from '@equaltoai/greater-components/adapters';
        
        let errorMessage = $state('');
        let isLoading = $state(true);
        
        const timeline = createTimelineStore({
          adapter,
          timeline: { type: 'home' },
        });

        $effect(() => {
          const unsubscribe = timeline.subscribe((state) => {
            isLoading = state.isLoading;
            errorMessage = state.error?.message ?? '';
          });

          void timeline.refresh();

          return unsubscribe;
        });
      </script>

      {#if errorMessage}
        <div class="error-banner">
          {errorMessage}
          <button onclick={() => timeline.refresh()} disabled={isLoading}>Retry</button>
        </div>
      {/if}
    anti_patterns:
      - name: 'Ignoring Errors'
        why: 'Users see broken UI with no explanation or recovery path'
        incorrect_example: |
          // INCORRECT: Don't ignore errors silently
          // Users have no idea what went wrong or how to fix it
          const timeline = createTimelineStore({ adapter, timeline: { type: 'home' } });

          // Timeline fails but user sees loading spinner forever
        consequences:
          - poor_user_experience
          - no_error_feedback
          - no_recovery_path
          - difficult_debugging

  responsive_design:
    name: 'Implementing Responsive Layouts'
    problem: 'Components must work on mobile, tablet, and desktop'
    solution: 'Use responsive design tokens and media queries'
    correct_example: |
      <script>
        // CORRECT: Components adapt to screen size
        // Use responsive props and CSS media queries
        import { Modal, Button } from '@equaltoai/greater-components/primitives';
        
        let isMobile = $state(false);
        
        $effect(() => {
          const checkMobile = () => {
            isMobile = window.innerWidth < 768;
          };
          checkMobile();
          window.addEventListener('resize', checkMobile);
          return () => window.removeEventListener('resize', checkMobile);
        });
      </script>

      <Modal 
        open={true}
        size={isMobile ? 'full' : 'lg'}
        title="Settings"
      >
        <p>Content adapts to screen size</p>
      </Modal>

      <style>
        /* Mobile-first responsive design */
        .container {
          padding: var(--gr-spacing-sm);
        }
        
        @media (min-width: 768px) {
          .container {
            padding: var(--gr-spacing-lg);
          }
        }
      </style>
    anti_patterns:
      - name: 'Fixed Pixel Dimensions'
        why: 'Breaks on different screen sizes and zoom levels'
        incorrect_example: |
          // INCORRECT: Don't use fixed pixel dimensions
          // Breaks responsive design and accessibility (zoom)
          <style>
            .modal {
              width: 800px; /* Fixed width breaks on mobile */
              height: 600px;
            }
            
            .button {
              font-size: 14px; /* Ignores user font size preferences */
            }
          </style>
        consequences:
          - breaks_on_mobile
          - horizontal_scrolling
          - ignores_user_zoom
          - poor_accessibility

  state_management:
    name: 'Managing Component State with Runes'
    problem: 'Need reactive state management in Svelte 5'
    solution: 'Use $state, $derived, and $effect runes'
    correct_example: |
      <script>
        // CORRECT: Use Svelte 5 runes for state management
        // Provides fine-grained reactivity
        import { Button } from '@equaltoai/greater-components/primitives';
        
        // Reactive state
        let count = $state(0);
        
        // Derived value
        let doubled = $derived(count * 2);
        
        // Side effect
        $effect(() => {
          console.log(`Count changed to ${count}`);
          document.title = `Count: ${count}`;
        });
      </script>

      <Button onclick={() => count++}>
        Clicked {count} times (doubled: {doubled})
      </Button>
    anti_patterns:
      - name: 'Using Legacy Reactive Statements'
        why: 'Svelte 5 uses runes, not $: reactive statements'
        incorrect_example: |
          // INCORRECT: Don't use legacy Svelte 3/4 patterns
          // Svelte 5 uses runes instead of $: syntax
          <script>
            let count = 0; // Not reactive in Svelte 5
            
            // Old pattern - doesn't work in Svelte 5
            $: doubled = count * 2;
            
            $: {
              console.log(count); // Old side effect pattern
            }
          </script>
        consequences:
          - not_reactive_in_svelte_5
          - compilation_warnings
          - unexpected_behavior
          - must_use_runes

  landing_page_layout:
    name: 'Building Landing Pages with Layout Components'
    problem: 'Need to build marketing landing page with Greater Components'
    solution: 'Use Container + Section for structure, Card for features, Heading + Text for typography, Button for CTAs'
    correct_example: |
      <script>
        import { 
          Container, 
          Section, 
          Heading, 
          Text, 
          Button, 
          Card 
        } from '@equaltoai/greater-components/primitives';
        import { ArrowRightIcon, CheckCircleIcon } from '@equaltoai/greater-components/icons';
      </script>

      <main>
        <!-- Hero Section -->
        <Section spacing="xl">
          <Container maxWidth="lg" padding="md">
            <Heading level={1} size="5xl" align="center">
              Build Amazing Products
            </Heading>
            
            <Text size="xl" color="secondary" align="center">
              Transform your ideas into reality with our platform
            </Text>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
              <Button variant="solid" size="lg">
                Get Started
                {#snippet suffix()}<ArrowRightIcon />{/snippet}
              </Button>
              <Button variant="outline" size="lg">
                Learn More
              </Button>
            </div>
          </Container>
        </Section>
        
        <!-- Features Section -->
        <Section spacing="lg">
          <Container maxWidth="xl">
            <Heading level={2} align="center">
              Features
            </Heading>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; margin-top: 3rem;">
              <Card variant="outlined" hoverable>
                {#snippet header()}
                  <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <CheckCircleIcon />
                    <Heading level={3} size="xl">Feature One</Heading>
                  </div>
                {/snippet}
                
                <Text color="secondary">
                  Description of your amazing feature goes here.
                </Text>
              </Card>
              
              <Card variant="outlined" hoverable>
                {#snippet header()}
                  <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <CheckCircleIcon />
                    <Heading level={3} size="xl">Feature Two</Heading>
                  </div>
                {/snippet}
                
                <Text color="secondary">
                  Another feature description.
                </Text>
              </Card>
            </div>
          </Container>
        </Section>
      </main>

    why_this_works:
      - container_constrains_width_for_readability
      - section_provides_vertical_rhythm
      - heading_maintains_semantic_structure
      - text_provides_consistent_typography
      - card_groups_related_content
      - css_grid_handles_responsive_layout

    anti_patterns:
      - name: 'Looking for Grid component'
        why: "Grid component doesn't exist, use CSS Grid"
        incorrect_example: |
          // WRONG: Grid component does not exist
          import { Grid } from '@equaltoai/greater-components/primitives';

          <Grid columns={3}>
            <Card>...</Card>
          </Grid>
        correct_example: |
          // CORRECT: Use CSS Grid directly
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2rem;">
            <Card>...</Card>
            <Card>...</Card>
            <Card>...</Card>
          </div>
        consequences:
          - import_error_grid_not_found
          - should_use_css_grid_instead

      - name: 'Looking for Nav/Navbar component'
        why: "Navigation components don't exist, build with HTML + primitives"
        incorrect_example: |
          // WRONG: Nav component does not exist
          import { Navbar } from '@equaltoai/greater-components/primitives';
        correct_example: |
          // CORRECT: Build nav with HTML + Container + Button
          <nav>
            <Container maxWidth="xl" padding="md">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <Heading level={1} size="lg">Logo</Heading>
                <div style="display: flex; gap: 1rem;">
                  <Button variant="ghost">About</Button>
                  <Button variant="ghost">Pricing</Button>
                  <Button variant="solid">Sign Up</Button>
                </div>
              </div>
            </Container>
          </nav>
        consequences:
          - import_error_navbar_not_found
          - should_use_html_nav_with_primitives

  typography_composition:
    name: 'Typography with Heading and Text Components'
    problem: 'Need consistent typography across pages with semantic structure'
    solution: 'Use Heading for all headings (h1-h6), Text for body content with variants'
    correct_example: |
      <script>
        import { Heading, Text } from '@equaltoai/greater-components/primitives';
      </script>

      <article>
        <!-- Main title -->
        <Heading level={1} size="4xl">
          Article Title
        </Heading>
        
        <!-- Meta info -->
        <Text size="sm" color="secondary">
          Published on Nov 19, 2025 · 5 min read
        </Text>
        
        <!-- Section -->
        <Heading level={2} size="2xl">
          Introduction
        </Heading>
        
        <!-- Body paragraphs -->
        <Text size="base">
          First paragraph of content goes here with consistent typography.
        </Text>
        
        <Text size="base" color="secondary">
          Secondary information or quotes can use different color variants.
        </Text>
        
        <!-- Subsection -->
        <Heading level={3} size="xl">
          Subsection Title
        </Heading>
        
        <Text>
          More content here.
        </Text>
      </article>

    why_this_works:
      - proper_heading_hierarchy_for_seo
      - screen_reader_friendly_structure
      - consistent_typography_via_design_tokens
      - visual_size_independent_of_semantic_level
      - color_variants_for_visual_hierarchy

    anti_patterns:
      - name: 'Using Heading for non-heading content'
        why: 'Heading component is semantic (h1-h6), not just for large text'
        incorrect_example: |
          // WRONG: Using h6 just to get small bold text
          <Heading level={6}>Call us at: 555-1234</Heading>
        correct_example: |
          // CORRECT: Use Text with styling for non-heading content
          <Text size="sm" weight="bold">Call us at: 555-1234</Text>
        consequences:
          - breaks_heading_hierarchy
          - confuses_screen_readers
          - poor_seo_structure

      - name: 'Skipping heading levels'
        why: 'Must maintain heading hierarchy (h1 → h2 → h3, not h1 → h3)'
        incorrect_example: |
          <Heading level={1}>Page Title</Heading>
          <Heading level={3}>Skipped h2!</Heading>  // WRONG
        correct_example: |
          <Heading level={1}>Page Title</Heading>
          <Heading level={2}>Section Title</Heading>
          <Heading level={3}>Subsection Title</Heading>
        consequences:
          - accessibility_violation
          - screen_reader_confusion
          - seo_penalty

  card_composition:
    name: 'Using Card Component for Content Blocks'
    problem: 'Need to display grouped content with visual separation'
    solution: 'Use Card component with header/footer snippets for structured content'
    correct_example: |
      <script>
        import { Card, Button } from '@equaltoai/greater-components/primitives';
      </script>

      <!-- Static card -->
      <Card variant="elevated" padding="lg">
        {#snippet header()}
          <h3>Pricing Plan</h3>
        {/snippet}
        
        <p>$29/month</p>
        <ul>
          <li>Feature 1</li>
          <li>Feature 2</li>
        </ul>
        
        {#snippet footer()}
          <Button variant="solid">Choose Plan</Button>
        {/snippet}
      </Card>

      <!-- Interactive card -->
      <Card 
        variant="outlined" 
        clickable 
        hoverable
        onclick={() => navigateTo('/product/123')}
      >
        <h3>Product Name</h3>
        <p>Product description...</p>
      </Card>

    why_this_works:
      - visual_separation_with_borders_shadows
      - header_footer_provide_structure
      - clickable_makes_entire_card_interactive
      - hoverable_provides_visual_feedback

    anti_patterns:
      - name: 'Nesting cards too deeply'
        why: 'Cards within cards can look cluttered'
        incorrect_example: |
          <Card>
            <Card>
              <Card>Content</Card>
            </Card>
          </Card>
        consequences:
          - visual_confusion
          - excessive_borders
          - poor_visual_hierarchy

  css_setup_minimal:
    name: 'Minimal CSS Setup'
    problem: 'Need to set up CSS imports for a basic Greater Components app'
    solution: 'Import both design tokens and component styles in your root layout'
    use_when:
      - starting_new_greater_components_project
      - using_only_primitive_components
      - want_smallest_css_bundle
    correct_example: |
      <!-- src/routes/+layout.svelte -->
      <script lang="ts">
        // CORRECT: Import BOTH CSS layers in root layout
        // Layer 1: Design tokens (colors, spacing, typography variables)
        import '@equaltoai/greater-components/tokens/theme.css';
        // Layer 2: Component styles (button, card, container classes)
        import '@equaltoai/greater-components/primitives/style.css';

        import { ThemeProvider } from '@equaltoai/greater-components/primitives';

        let { children } = $props();
      </script>

      <ThemeProvider>
        {@render children()}
      </ThemeProvider>
    anti_patterns:
      - name: 'Missing component styles'
        why: 'Components render but appear as browser defaults'
        incorrect_example: |
          // INCORRECT: Only importing tokens without component styles
          import '@equaltoai/greater-components/tokens/theme.css';
          import { Button } from '@equaltoai/greater-components/primitives';
          // Button will render but look unstyled!
        consequences:
          - components_render_unstyled
          - buttons_look_like_browser_defaults
          - cards_have_no_shadow
      - name: 'Wrong import order'
        why: 'Component styles reference token variables that must exist first'
        incorrect_example: |
          // INCORRECT: Component styles before tokens
          import '@equaltoai/greater-components/primitives/style.css';
          import '@equaltoai/greater-components/tokens/theme.css';
        consequences:
          - css_variables_undefined
          - partial_styling_issues
      - name: 'CSS in page component instead of layout'
        why: 'CSS imports should be in root layout to ensure they load first'
        incorrect_example: |
          // INCORRECT: Importing CSS in +page.svelte instead of +layout.svelte
          // src/routes/+page.svelte
          import '@equaltoai/greater-components/tokens/theme.css';
          // Too late! Other components may have already loaded
        consequences:
          - flash_of_unstyled_content
          - inconsistent_styling

  css_setup_full:
    name: 'Full CSS Setup (All Components)'
    problem: 'Need CSS imports for apps using social face components'
    solution: 'Import the face CSS after primitives'
    use_when:
      - using_social_face_components
      - building_social_media_features
      - need_timeline_status_profile_components
    correct_example: |
      <!-- src/routes/+layout.svelte -->
      <script lang="ts">
        // CORRECT: Tokens first, then primitives, then face styles
        import '@equaltoai/greater-components/tokens/theme.css';
        import '@equaltoai/greater-components/primitives/style.css';
        import '@equaltoai/greater-components/faces/social/style.css';

        import { ThemeProvider } from '@equaltoai/greater-components/primitives';

        let { children } = $props();
      </script>

      <ThemeProvider>
        {@render children()}
      </ThemeProvider>
    why_this_works:
      - face_styles_extend_primitives_classes
      - social_components_properly_styled
      - modular_css_imports_match_package_structure

  css_setup_dark_theme:
    name: 'Dark Theme CSS Setup'
    problem: 'Want dark mode as the default theme'
    solution: 'Import dark theme override after base tokens'
    use_when:
      - building_dark_mode_ui
      - want_dark_theme_as_default
    correct_example: |
      <!-- src/routes/+layout.svelte -->
      <script lang="ts">
        // CORRECT: Dark theme setup
        // 1. Base tokens first
        import '@equaltoai/greater-components/tokens/theme.css';
        // 2. Dark theme overrides
        import '@equaltoai/greater-components/tokens/themes/dark.css';
        // 3. Component styles last
        import '@equaltoai/greater-components/primitives/style.css';

        import { ThemeProvider } from '@equaltoai/greater-components/primitives';

        let { children } = $props();
      </script>

      <ThemeProvider defaultTheme="dark">
        {@render children()}
      </ThemeProvider>
    why_this_works:
      - theme_override_comes_after_base_tokens
      - theme_override_comes_before_component_styles
      - css_cascade_applies_dark_values

  theme_flash_prevention:
    name: 'Prevent Theme Flash on Page Load'
    problem: 'Brief flash of wrong theme colors when page loads'
    solution: 'Add inline script to app.html that applies theme before render'
    use_when:
      - supporting_theme_switching
      - storing_theme_preference_in_localstorage
      - want_seamless_theme_persistence
    correct_example: |
      <!-- src/app.html -->
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          
          <!-- CORRECT: Inline script runs before page renders -->
          <script>
            (function() {
              const theme = localStorage.getItem('gr-theme') || 'light';
              document.documentElement.setAttribute('data-theme', theme);
            })();
          </script>
          
          %sveltekit.head%
        </head>
        <body data-sveltekit-preload-data="hover">
          <div style="display: contents">%sveltekit.body%</div>
        </body>
      </html>
    why_this_works:
      - inline_script_runs_immediately
      - theme_applied_before_first_render
      - no_visible_flash

  # ============================================================================
  # Chat Component Patterns
  # ============================================================================

  chat_basic_interface:
    name: 'Basic Chat Interface Setup'
    problem: 'Need a complete AI chat interface with messages and input'
    solution: 'Use Chat namespace components with Container, Messages, Input'
    use_when:
      - building_ai_chat_interface
      - creating_conversational_ui
      - integrating_with_ai_api
    correct_example: |
      <script lang="ts">
        // CORRECT: Import Chat components as namespace
        // Provides clear API and component relationships
        import * as Chat from '@equaltoai/greater-components/chat';
        
        let messages = $state<Chat.ChatMessage[]>([]);
        
        async function handleSend(content: string) {
          // Add user message
          const userMessage: Chat.ChatMessage = {
            id: crypto.randomUUID(),
            role: 'user',
            content,
            timestamp: new Date(),
            status: 'complete',
          };
          messages = [...messages, userMessage];
          
          // Call your AI API
          const response = await fetch('/api/chat', {
            method: 'POST',
            body: JSON.stringify({ message: content }),
          });
          const data = await response.json();
          
          // Add assistant response
          const assistantMessage: Chat.ChatMessage = {
            id: crypto.randomUUID(),
            role: 'assistant',
            content: data.content,
            timestamp: new Date(),
            status: 'complete',
          };
          messages = [...messages, assistantMessage];
        }
      </script>

      <Chat.Container>
        <Chat.Header title="AI Assistant" connectionStatus="connected" />
        <Chat.Messages {messages} />
        <Chat.Input placeholder="Ask me anything..." onSend={handleSend} />
      </Chat.Container>
    anti_patterns:
      - name: 'Using individual imports without namespace'
        why: 'Makes it unclear which package components come from'
        incorrect_example: |
          // INCORRECT: Loses namespace context
          import { Container, Messages, Input } from '@equaltoai/greater-components/chat';
          // Unclear these are Chat components vs other Container/Input
        consequences:
          - naming_confusion
          - unclear_component_relationships
      - name: 'Mutating messages array directly'
        why: 'Svelte 5 runes require reassignment for reactivity'
        incorrect_example: |
          // INCORRECT: Array mutation doesn't trigger reactivity
          messages.push(newMessage);  // Won't update UI!

          // CORRECT: Reassign with spread
          messages = [...messages, newMessage];
        consequences:
          - messages_not_appearing
          - broken_reactivity
          - ui_not_updating

  chat_streaming_responses:
    name: 'Handling Streaming Responses'
    problem: 'Need to show real-time streaming AI responses'
    solution: 'Use streaming status and update message content progressively'
    use_when:
      - integrating_with_streaming_api
      - showing_real_time_responses
      - improving_perceived_performance
    correct_example: |
      <script lang="ts">
        import * as Chat from '@equaltoai/greater-components/chat';
        
        let messages = $state<Chat.ChatMessage[]>([]);
        
        async function handleSend(content: string) {
          // Add user message
          messages = [...messages, {
            id: crypto.randomUUID(),
            role: 'user',
            content,
            timestamp: new Date(),
            status: 'complete',
          }];
          
          // Create streaming placeholder
          const assistantId = crypto.randomUUID();
          messages = [...messages, {
            id: assistantId,
            role: 'assistant',
            content: '',
            timestamp: new Date(),
            status: 'streaming',  // Key: streaming status shows cursor
          }];
          
          // Stream response
          const response = await fetch('/api/chat/stream', {
            method: 'POST',
            body: JSON.stringify({ message: content }),
          });
          
          const reader = response.body!.getReader();
          const decoder = new TextDecoder();
          let fullContent = '';
          
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            fullContent += decoder.decode(value);
            
            // Update message content progressively
            messages = messages.map(m => 
              m.id === assistantId 
                ? { ...m, content: fullContent }
                : m
            );
          }
          
          // Mark complete when done
          messages = messages.map(m => 
            m.id === assistantId 
              ? { ...m, status: 'complete' }
              : m
          );
        }
      </script>
    why_this_works:
      - streaming_status_shows_blinking_cursor
      - progressive_updates_show_real_time_output
      - complete_status_removes_cursor

  chat_with_tool_calls:
    name: 'Displaying Tool/Function Calls'
    problem: 'Need to show AI tool invocations and their results'
    solution: 'Include toolCalls in message and use ToolCall component'
    use_when:
      - ai_uses_tools_or_functions
      - showing_tool_execution_status
      - debugging_ai_tool_usage
    correct_example: |
      <script lang="ts">
        import * as Chat from '@equaltoai/greater-components/chat';
        
        let messages = $state<Chat.ChatMessage[]>([]);
        
        async function handleToolCall(toolCall: Chat.ToolCall) {
          // Execute tool
          const result = await executeToolOnBackend(toolCall.tool, toolCall.args);
          
          // Update tool call with result
          messages = messages.map(m => ({
            ...m,
            toolCalls: m.toolCalls?.map(tc =>
              tc.id === toolCall.id
                ? { ...tc, result, status: 'complete' as const }
                : tc
            )
          }));
          
          return result;
        }
        
        // Example message with tool calls
        const messageWithTools: Chat.ChatMessage = {
          id: '1',
          role: 'assistant',
          content: 'Let me search the knowledge base for you...',
          timestamp: new Date(),
          status: 'complete',
          toolCalls: [
            {
              id: 'tc1',
              tool: 'query_knowledge',
              args: { query: 'Svelte 5 runes' },
              result: 'Found 3 documents...',
              status: 'complete',
            }
          ]
        };
      </script>

      <!-- Messages component automatically renders tool calls -->
      <Chat.Messages {messages} />

      <!-- Or render tool calls manually in custom layout -->
      {#each message.toolCalls as toolCall}
        <Chat.ToolCall {toolCall} collapsible={true} />
      {/each}
    why_this_works:
      - tool_calls_embedded_in_message
      - status_indicators_show_progress
      - collapsible_details_reduce_clutter

  chat_with_suggestions:
    name: 'Empty State with Suggestions'
    problem: 'Need helpful prompts when chat is empty'
    solution: 'Use Suggestions component with custom prompts'
    use_when:
      - guiding_new_users
      - providing_quick_start_prompts
      - showing_capabilities
    correct_example: |
      <script lang="ts">
        import * as Chat from '@equaltoai/greater-components/chat';
        
        let messages = $state<Chat.ChatMessage[]>([]);
        
        async function handleSend(content: string) {
          // ... send logic
        }
        
        // Custom suggestions for your use case
        const suggestions = [
          'What can you help me with?',
          'Generate a React component',
          'Explain this error message',
          'Review my code for bugs',
        ];
      </script>

      <Chat.Container>
        <Chat.Header title="Code Assistant" />
        
        {#if messages.length === 0}
          <!-- Show suggestions in empty state -->
          <div class="empty-state">
            <h3>How can I help you today?</h3>
            <Chat.Suggestions 
              {suggestions}
              variant="cards"
              onSelect={(s) => handleSend(s)}
            />
          </div>
        {:else}
          <Chat.Messages {messages} />
        {/if}
        
        <Chat.Input onSend={handleSend} />
      </Chat.Container>
    alternative_with_default_suggestions: |
      // Use built-in PAI suggestions
      import { defaultPAISuggestions } from '@equaltoai/greater-components/chat';

      <Chat.Suggestions 
        suggestions={defaultPAISuggestions}
        onSelect={handleSend}
      />

  chat_with_settings:
    name: 'Configurable Chat Settings'
    problem: 'Need user-configurable AI settings (model, temperature)'
    solution: 'Use Settings component with ChatSettingsState'
    use_when:
      - allowing_model_selection
      - configuring_ai_parameters
      - advanced_user_controls
    correct_example: |
      <script lang="ts">
        import * as Chat from '@equaltoai/greater-components/chat';
        
        let messages = $state<Chat.ChatMessage[]>([]);
        let settingsOpen = $state(false);
        
        let settings = $state<Chat.ChatSettingsState>({
          model: 'gpt-4',
          temperature: 0.7,
          maxTokens: 4096,
          streaming: true,
        });
        
        const availableModels = [
          { id: 'gpt-4', name: 'GPT-4' },
          { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo' },
          { id: 'claude-3', name: 'Claude 3' },
        ];
        
        async function handleSend(content: string) {
          // Use settings.model, settings.temperature in API call
          const response = await fetch('/api/chat', {
            method: 'POST',
            body: JSON.stringify({
              message: content,
              model: settings.model,
              temperature: settings.temperature,
            }),
          });
          // ... handle response
        }
      </script>

      <Chat.Container>
        <Chat.Header 
          title="AI Assistant"
          showSettingsButton={true}
          onSettings={() => settingsOpen = true}
        />
        <Chat.Messages {messages} />
        <Chat.Input onSend={handleSend} />
      </Chat.Container>

      <Chat.Settings 
        bind:open={settingsOpen}
        {settings}
        {availableModels}
        onSettingsChange={(s) => settings = s}
      />

  chat_context_api:
    name: 'Using Chat Context for Shared State'
    problem: 'Need to share chat state across multiple components'
    solution: 'Use createChatContext and getChatContext'
    use_when:
      - building_complex_chat_layouts
      - sharing_state_across_components
      - custom_chat_component_composition
    correct_example: |
      <!-- ChatWrapper.svelte - Parent component -->
      <script lang="ts">
        import * as Chat from '@equaltoai/greater-components/chat';
        
        // Create context with handlers
        const context = Chat.createChatContext({
          onSubmit: async (content) => {
            // Handle sending message
            await sendToAPI(content);
          },
          onClear: () => {
            // Handle clearing conversation
          },
        }, {
          model: 'gpt-4',
          temperature: 0.7,
        });
      </script>

      <Chat.Container>
        <slot />
      </Chat.Container>

      <!-- CustomMessageList.svelte - Child component -->
      <script lang="ts">
        import * as Chat from '@equaltoai/greater-components/chat';
        
        // Access context from parent Container
        const context = Chat.getChatContext();
        
        // Use context methods
        function addSystemMessage() {
          context.addMessage({
            role: 'system',
            content: 'System notification',
            status: 'complete',
          });
        }
      </script>

      <div>
        {#each context.state.messages as message}
          <Chat.Message {message} />
        {/each}
        
        <button onclick={addSystemMessage}>
          Add System Message
        </button>
      </div>
    anti_patterns:
      - name: 'Using getChatContext outside Container'
        why: 'Context must be provided by parent Container'
        incorrect_example: |
          // INCORRECT: No Container parent
          <script>
            import { getChatContext } from '@equaltoai/greater-components/chat';
            
            // This will throw an error!
            const context = getChatContext();
          </script>
        consequences:
          - runtime_error
          - context_not_found

  chat_websocket_integration:
    name: 'WebSocket Integration with pai-socket'
    problem: 'Need real-time streaming via WebSocket'
    solution: 'Connect to WebSocket and update messages from events'
    use_when:
      - using_pai_socket
      - real_time_bidirectional_communication
      - server_push_updates
    correct_example: |
      <script lang="ts">
        import * as Chat from '@equaltoai/greater-components/chat';
        
        let messages = $state<Chat.ChatMessage[]>([]);
        let connectionStatus = $state<'connected' | 'connecting' | 'disconnected'>('disconnected');
        let ws: WebSocket | null = null;
        let currentStreamId: string | null = null;
        
        function connect() {
          connectionStatus = 'connecting';
          ws = new WebSocket('wss://api.example.com/ws');
          
          ws.onopen = () => {
            connectionStatus = 'connected';
          };
          
          ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            handleServerMessage(data);
          };
          
          ws.onclose = () => {
            connectionStatus = 'disconnected';
          };
        }
        
        function handleServerMessage(data: any) {
          switch (data.type) {
            case 'content.delta':
              // Update streaming message content
              messages = messages.map(m =>
                m.id === currentStreamId
                  ? { ...m, content: m.content + data.content }
                  : m
              );
              break;
              
            case 'tool.start':
              // Add tool call to message
              messages = messages.map(m =>
                m.id === currentStreamId
                  ? {
                      ...m,
                      toolCalls: [...(m.toolCalls || []), {
                        id: data.toolCallId,
                        tool: data.toolName,
                        args: data.args,
                        status: 'running',
                      }]
                    }
                  : m
              );
              break;
              
            case 'tool.complete':
              // Update tool call result
              messages = messages.map(m => ({
                ...m,
                toolCalls: m.toolCalls?.map(tc =>
                  tc.id === data.toolCallId
                    ? { ...tc, result: data.result, status: 'complete' }
                    : tc
                )
              }));
              break;
              
            case 'complete':
              // Mark message complete
              messages = messages.map(m =>
                m.id === currentStreamId
                  ? { ...m, status: 'complete' }
                  : m
              );
              currentStreamId = null;
              break;
          }
        }
        
        function handleSend(content: string) {
          // Add user message
          messages = [...messages, {
            id: crypto.randomUUID(),
            role: 'user',
            content,
            timestamp: new Date(),
            status: 'complete',
          }];
          
          // Create streaming placeholder
          currentStreamId = crypto.randomUUID();
          messages = [...messages, {
            id: currentStreamId,
            role: 'assistant',
            content: '',
            timestamp: new Date(),
            status: 'streaming',
          }];
          
          // Send to WebSocket
          ws?.send(JSON.stringify({
            action: 'ai.chat',
            content,
          }));
        }
      </script>

      <Chat.Container>
        <Chat.Header 
          title="PAI Assistant" 
          {connectionStatus}
          showClearButton={true}
          onClear={() => messages = []}
        />
        <Chat.Messages {messages} />
        <Chat.Input onSend={handleSend} disabled={connectionStatus !== 'connected'} />
      </Chat.Container>
    why_this_works:
      - websocket_provides_real_time_updates
      - message_events_update_ui_progressively
      - connection_status_shown_in_header
