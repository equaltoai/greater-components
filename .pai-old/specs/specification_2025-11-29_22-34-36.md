# BEGIN MODULES LIST

## BEGIN MODULE

### Module: Chat Context Implementation
Complete implementation of the chat context system with Svelte 5 $state runes, providing reactive state management for the chat component suite.

## Description
This module implements the complete chat context system at `packages/shared/chat/src/context.svelte.ts` (renamed from context.ts to enable Svelte 5 runes). The context provides:
- Reactive state management using Svelte 5 `$state` runes
- `ChatContextValue` interface with state (messages, streaming, streamContent, connectionStatus, error) and actions (sendMessage, clearMessages, retryLastMessage, cancelStream)
- `ToolCall` interface with id, tool, args, result, and status fields (already defined in types.ts)
- Factory function `createChatContext(handlers)` for creating context instances
- Accessor function `getChatContext()` for child components
- Utility functions for message formatting (timestamps, etc.)
- Connection status management for streaming scenarios
- Following the established messaging package pattern with `getContext`/`setContext` from Svelte

Note: File must be `.svelte.ts` to use `$state` runes per Svelte 5 documentation.

## Type
creation

## Dependencies
none

## Files
packages/shared/chat/src/context.svelte.ts

## File Changes
- packages/shared/chat/src/context.svelte.ts: BEFORE: DOES NOT EXIST | AFTER: <<</**
 * Chat Context
 *
 * Provides shared state and handlers for all chat components.
 * Supports message management, streaming, tool calls, and settings.
 *
 * @module Chat/context
 */

import { getContext, setContext } from 'svelte';
import type {
  ChatMessage,
  ChatSettingsState,
  ToolCall,
  ToolCallStatus,
} from './types.js';

/**
 * Chat context key
 */
const CHAT_CONTEXT_KEY = Symbol('chat-context');

/**
 * Connection status for streaming
 */
export type ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'error';

/**
 * Chat event handlers
 */
export interface ChatHandlers {
  /**
   * Called when a message is submitted
   */
  onSubmit?: (content: string) => Promise<void> | void;

  /**
   * Called when a message should be regenerated
   */
  onRegenerate?: (messageId: string) => Promise<void> | void;

  /**
   * Called when a message should be edited
   */
  onEdit?: (messageId: string, content: string) => Promise<void> | void;

  /**
   * Called when a message should be deleted
   */
  onDelete?: (messageId: string) => Promise<void> | void;

  /**
   * Called when the conversation should be cleared
   */
  onClear?: () => Promise<void> | void;

  /**
   * Called when settings change
   */
  onSettingsChange?: (settings: ChatSettingsState) => void;

  /**
   * Called when streaming should be stopped/cancelled
   */
  onStopStreaming?: () => void;

  /**
   * Called when the last message should be retried
   */
  onRetry?: () => Promise<void> | void;
}

/**
 * Chat state
 */
export interface ChatState {
  /** All messages in the conversation */
  messages: ChatMessage[];
  /** Whether a response is being generated */
  loading: boolean;
  /** Whether a response is being streamed */
  streaming: boolean;
  /** Current streaming content (partial response) */
  streamContent: string;
  /** Current connection status */
  connectionStatus: ConnectionStatus;
  /** Current error message */
  error: string | null;
  /** Current settings */
  settings: ChatSettingsState;
  /** Whether settings panel is open */
  settingsOpen: boolean;
}

/**
 * Chat context value
 */
export interface ChatContextValue {
  /** Current chat state */
  state: ChatState;
  /** Event handlers */
  handlers: ChatHandlers;
  /** Update state helper */
  updateState: (partial: Partial<ChatState>) => void;
  /** Add a message to the conversation */
  addMessage: (message: Omit<ChatMessage, 'id' | 'timestamp'>) => ChatMessage;
  /** Update an existing message */
  updateMessage: (id: string, updates: Partial<ChatMessage>) => void;
  /** Remove a message */
  removeMessage: (id: string) => void;
  /** Clear all messages */
  clearMessages: () => void;
  /** Set error state */
  setError: (error: string | null) => void;
  /** Toggle settings panel */
  toggleSettings: () => void;
  /** Send a message (calls onSubmit handler) */
  sendMessage: (content: string) => Promise<void>;
  /** Retry the last failed message */
  retryLastMessage: () => Promise<void>;
  /** Cancel the current stream */
  cancelStream: () => void;
  /** Update stream content */
  updateStreamContent: (content: string) => void;
  /** Set connection status */
  setConnectionStatus: (status: ConnectionStatus) => void;
  /** Add a tool call to a message */
  addToolCall: (messageId: string, toolCall: Omit<ToolCall, 'id'>) => ToolCall;
  /** Update a tool call */
  updateToolCall: (messageId: string, toolCallId: string, updates: Partial<ToolCall>) => void;
}

/**
 * Generate a unique message ID
 */
function generateMessageId(): string {
  return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Generate a unique tool call ID
 */
function generateToolCallId(): string {
  return `tc_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Create chat context
 *
 * @param handlers - Chat event handlers
 * @param initialSettings - Initial settings state
 * @returns Chat context value
 */
export function createChatContext(
  handlers: ChatHandlers = {},
  initialSettings: ChatSettingsState = {}
): ChatContextValue {
  const state = $state<ChatState>({
    messages: [],
    loading: false,
    streaming: false,
    streamContent: '',
    connectionStatus: 'disconnected',
    error: null,
    settings: {
      model: undefined,
      temperature: 0.7,
      maxTokens: 4096,
      systemPrompt: undefined,
      streaming: true,
      ...initialSettings,
    },
    settingsOpen: false,
  });

  const context: ChatContextValue = {
    state,
    handlers,

    updateState: (partial: Partial<ChatState>) => {
      Object.assign(state, partial);
    },

    addMessage: (message: Omit<ChatMessage, 'id' | 'timestamp'>): ChatMessage => {
      const newMessage: ChatMessage = {
        ...message,
        id: generateMessageId(),
        timestamp: new Date(),
      };
      state.messages = [...state.messages, newMessage];
      return newMessage;
    },

    updateMessage: (id: string, updates: Partial<ChatMessage>) => {
      state.messages = state.messages.map((msg) =>
        msg.id === id ? { ...msg, ...updates } : msg
      );
    },

    removeMessage: (id: string) => {
      state.messages = state.messages.filter((msg) => msg.id !== id);
    },

    clearMessages: () => {
      state.messages = [];
      state.error = null;
      state.streamContent = '';
      state.streaming = false;
      handlers.onClear?.();
    },

    setError: (error: string | null) => {
      state.error = error;
      if (error) {
        state.connectionStatus = 'error';
      }
    },

    toggleSettings: () => {
      state.settingsOpen = !state.settingsOpen;
    },

    sendMessage: async (content: string) => {
      if (!content.trim() || state.loading) return;

      state.loading = true;
      state.error = null;
      state.streamContent = '';

      // Add user message
      context.addMessage({
        role: 'user',
        content: content.trim(),
        status: 'complete',
      });

      try {
        await handlers.onSubmit?.(content.trim());
      } catch (error) {
        state.error = error instanceof Error ? error.message : 'Failed to send message';
        // Mark the last assistant message as error if it exists
        const lastMessage = state.messages[state.messages.length - 1];
        if (lastMessage && lastMessage.role === 'assistant') {
          context.updateMessage(lastMessage.id, { 
            status: 'error',
            error: state.error,
          });
        }
      } finally {
        state.loading = false;
        state.streaming = false;
      }
    },

    retryLastMessage: async () => {
      // Find the last user message
      const lastUserMessageIndex = [...state.messages]
        .reverse()
        .findIndex((m) => m.role === 'user');
      
      if (lastUserMessageIndex === -1) return;

      const actualIndex = state.messages.length - 1 - lastUserMessageIndex;
      const lastUserMessage = state.messages[actualIndex];
      
      if (!lastUserMessage) return;

      // Remove all messages after the last user message
      state.messages = state.messages.slice(0, actualIndex + 1);
      state.error = null;
      state.loading = true;

      try {
        await handlers.onRetry?.();
      } catch (error) {
        state.error = error instanceof Error ? error.message : 'Failed to retry message';
      } finally {
        state.loading = false;
        state.streaming = false;
      }
    },

    cancelStream: () => {
      state.streaming = false;
      state.loading = false;
      handlers.onStopStreaming?.();
      
      // Mark any streaming message as complete with current content
      const streamingMessage = state.messages.find((m) => m.status === 'streaming');
      if (streamingMessage) {
        context.updateMessage(streamingMessage.id, {
          status: 'complete',
          content: state.streamContent || streamingMessage.content,
        });
      }
      state.streamContent = '';
    },

    updateStreamContent: (content: string) => {
      state.streamContent = content;
      state.streaming = true;
      
      // Update the streaming message content
      const streamingMessage = state.messages.find((m) => m.status === 'streaming');
      if (streamingMessage) {
        context.updateMessage(streamingMessage.id, { content });
      }
    },

    setConnectionStatus: (status: ConnectionStatus) => {
      state.connectionStatus = status;
    },

    addToolCall: (messageId: string, toolCall: Omit<ToolCall, 'id'>): ToolCall => {
      const newToolCall: ToolCall = {
        ...toolCall,
        id: generateToolCallId(),
      };

      state.messages = state.messages.map((msg) => {
        if (msg.id === messageId) {
          return {
            ...msg,
            toolCalls: [...(msg.toolCalls || []), newToolCall],
          };
        }
        return msg;
      });

      return newToolCall;
    },

    updateToolCall: (messageId: string, toolCallId: string, updates: Partial<ToolCall>) => {
      state.messages = state.messages.map((msg) => {
        if (msg.id === messageId && msg.toolCalls) {
          return {
            ...msg,
            toolCalls: msg.toolCalls.map((tc) =>
              tc.id === toolCallId ? { ...tc, ...updates } : tc
            ),
          };
        }
        return msg;
      });
    },
  };

  setContext(CHAT_CONTEXT_KEY, context);
  return context;
}

/**
 * Get chat context
 *
 * Must be called within a Chat component tree.
 *
 * @throws Error if called outside Chat component tree
 * @returns Chat context value
 */
export function getChatContext(): ChatContextValue {
  const context = getContext<ChatContextValue>(CHAT_CONTEXT_KEY);
  if (!context) {
    throw new Error('Chat components must be used within a Chat.Container component');
  }
  return context;
}

/**
 * Set chat context (for testing or custom implementations)
 *
 * @param context - Chat context value
 */
export function setChatContext(context: ChatContextValue): void {
  setContext(CHAT_CONTEXT_KEY, context);
}

/**
 * Check if chat context exists
 */
export function hasChatContext(): boolean {
  try {
    const context = getContext<ChatContextValue>(CHAT_CONTEXT_KEY);
    return context !== undefined && context !== null;
  } catch {
    return false;
  }
}

/**
 * Format message timestamp for display
 * 
 * @param timestamp - Message timestamp
 * @returns Formatted time string
 */
export function formatMessageTime(timestamp: Date | string): string {
  const date = typeof timestamp === 'string' ? new Date(timestamp) : timestamp;
  const now = new Date();
  const diff = now.getTime() - date.getTime();
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  // Today: show time
  if (days === 0) {
    return date.toLocaleTimeString(undefined, { 
      hour: 'numeric', 
      minute: '2-digit',
      hour12: true,
    });
  }

  // Yesterday
  if (days === 1) {
    return 'Yesterday';
  }

  // Within a week
  if (days < 7) {
    return date.toLocaleDateString(undefined, { weekday: 'long' });
  }

  // Older: show date
  return date.toLocaleDateString(undefined, {
    month: 'short',
    day: 'numeric',
    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined,
  });
}

/**
 * Format relative time for streaming indicators
 * 
 * @param seconds - Number of seconds
 * @returns Formatted duration string
 */
export function formatStreamDuration(seconds: number): string {
  if (seconds < 60) {
    return `${seconds}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds}s`;
}

/**
 * Get status text for connection status
 * 
 * @param status - Connection status
 * @returns Human-readable status text
 */
export function getConnectionStatusText(status: ConnectionStatus): string {
  switch (status) {
    case 'disconnected':
      return 'Disconnected';
    case 'connecting':
      return 'Connecting...';
    case 'connected':
      return 'Connected';
    case 'error':
      return 'Connection error';
    default:
      return 'Unknown';
  }
}>>> | TYPE: content creation | DESC: Create new context.svelte.ts file with Svelte 5 $state runes (requires .svelte.ts extension per Svelte 5 docs), enhanced ChatContextValue interface with streaming support, connection status, sendMessage/clearMessages/retryLastMessage/cancelStream actions, ToolCall management, and utility functions for message formatting

## Priority
high

## END MODULE

## BEGIN MODULE

### Module: Remove Old Context File
Remove the old context.ts file since it's being replaced by context.svelte.ts to enable Svelte 5 runes.

## Description
This module removes the old `packages/shared/chat/src/context.ts` file. The file is being replaced by `context.svelte.ts` because Svelte 5 `$state` runes can only be used in `.svelte`, `.svelte.js`, or `.svelte.ts` files according to official Svelte 5 documentation.

## Type
run command

## Dependencies
Chat Context Implementation

## Files
packages/shared/chat/src/context.ts

## File Changes
- packages/shared/chat/src/context.ts: COMMAND: <<<rm packages/shared/chat/src/context.ts>>> | BEFORE: [existing context.ts file content] | AFTER: [file deleted] | TYPE: terminal command | DESC: Remove old context.ts file that is being replaced by context.svelte.ts

## Priority
high

## END MODULE

## BEGIN MODULE

### Module: ChatContainer Component Implementation
Create the main ChatContainer.svelte component that wraps the chat interface and provides context to child components.

## Description
This module creates the `ChatContainer.svelte` component at `packages/shared/chat/src/ChatContainer.svelte`. The component:
- Uses Svelte 5 `$props()` syntax for props interface (messages, streaming, streamContent, class, children Snippet)
- Creates and provides chat context to children via `setContext`
- Implements auto-scroll to bottom on new messages using `$effect`
- Handles global keyboard shortcuts (Escape to cancel stream)
- Provides mobile-responsive flex layout with CSS
- Manages connection status state
- Uses Greater Components design tokens (`--gr-color-*`, `--gr-radii-*`, `--gr-spacing-scale-*`)
- Full dark mode support with `[data-theme='dark']` selectors
- Scoped CSS styling within the component
- Uses `$derived.by()` for complex derivations (per Svelte 5 docs)

## Type
creation

## Dependencies
Chat Context Implementation

## Files
packages/shared/chat/src/ChatContainer.svelte

## File Changes
- packages/shared/chat/src/ChatContainer.svelte: BEFORE: DOES NOT EXIST | AFTER: <<<<!--
  Chat.Container - Main Chat Container Component
  
  Provides the chat context and layout wrapper for all chat components.
  Handles auto-scroll, keyboard shortcuts, and responsive layout.
  
  @component
  @example
  ```svelte
  <Chat.Container {handlers}>
    <Chat.Header title="AI Assistant" />
    <Chat.Messages />
    <Chat.Input />
  </Chat.Container>
  ```
-->
<script lang="ts">
  import type { Snippet } from 'svelte';
  import { onMount, onDestroy } from 'svelte';
  import { createChatContext } from './context.svelte.js';
  import type { ChatHandlers, ChatState, ConnectionStatus } from './context.svelte.js';
  import type { ChatMessage, ChatSettingsState } from './types.js';

  /**
   * ChatContainer component props
   */
  interface Props {
    /**
     * Chat event handlers
     */
    handlers?: ChatHandlers;

    /**
     * Initial messages to display
     */
    messages?: ChatMessage[];

    /**
     * Whether currently streaming a response
     */
    streaming?: boolean;

    /**
     * Current stream content (partial response)
     */
    streamContent?: string;

    /**
     * Initial connection status
     */
    connectionStatus?: ConnectionStatus;

    /**
     * Initial settings
     */
    initialSettings?: ChatSettingsState;

    /**
     * Whether to auto-scroll to new messages
     * @default true
     */
    autoScroll?: boolean;

    /**
     * Whether to enable keyboard shortcuts
     * @default true
     */
    enableKeyboardShortcuts?: boolean;

    /**
     * Custom CSS class
     */
    class?: string;

    /**
     * Child components
     */
    children?: Snippet;
  }

  let {
    handlers = {},
    messages = [],
    streaming = false,
    streamContent = '',
    connectionStatus = 'disconnected',
    initialSettings = {},
    autoScroll = true,
    enableKeyboardShortcuts = true,
    class: className = '',
    children,
  }: Props = $props();

  // Create chat context
  const context = createChatContext(handlers, initialSettings);

  // Container element reference for scrolling
  let containerRef: HTMLDivElement | undefined = $state();
  let messagesEndRef: HTMLDivElement | undefined = $state();

  // Sync external props with context state
  $effect(() => {
    if (messages.length > 0) {
      context.updateState({ messages });
    }
  });

  $effect(() => {
    context.updateState({ streaming, streamContent });
  });

  $effect(() => {
    context.setConnectionStatus(connectionStatus);
  });

  // Auto-scroll to bottom when new messages arrive
  $effect(() => {
    if (autoScroll && context.state.messages.length > 0) {
      scrollToBottom();
    }
  });

  // Auto-scroll during streaming
  $effect(() => {
    if (autoScroll && context.state.streaming) {
      scrollToBottom();
    }
  });

  /**
   * Scroll to the bottom of the messages container
   */
  function scrollToBottom() {
    if (messagesEndRef) {
      messagesEndRef.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }
  }

  /**
   * Handle keyboard shortcuts
   */
  function handleKeydown(event: KeyboardEvent) {
    if (!enableKeyboardShortcuts) return;

    // Escape to cancel streaming
    if (event.key === 'Escape' && context.state.streaming) {
      event.preventDefault();
      context.cancelStream();
    }

    // Ctrl/Cmd + Shift + Backspace to clear messages
    if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === 'Backspace') {
      event.preventDefault();
      context.clearMessages();
    }
  }

  // Set up global keyboard listener
  onMount(() => {
    if (enableKeyboardShortcuts) {
      window.addEventListener('keydown', handleKeydown);
    }
  });

  onDestroy(() => {
    if (enableKeyboardShortcuts) {
      window.removeEventListener('keydown', handleKeydown);
    }
  });

  // Compute container classes using $derived.by for complex logic
  const containerClass = $derived.by(() => {
    const classes = [
      'chat-container',
      context.state.streaming && 'chat-container--streaming',
      context.state.loading && 'chat-container--loading',
      context.state.error && 'chat-container--error',
      context.state.connectionStatus === 'connected' && 'chat-container--connected',
      context.state.connectionStatus === 'connecting' && 'chat-container--connecting',
      context.state.connectionStatus === 'error' && 'chat-container--connection-error',
      className,
    ]
      .filter(Boolean)
      .join(' ');

    return classes;
  });
</script>

<div
  bind:this={containerRef}
  class={containerClass}
  role="region"
  aria-label="Chat conversation"
  aria-live="polite"
>
  <div class="chat-container__inner">
    {#if children}
      {@render children()}
    {/if}
    
    <!-- Scroll anchor for auto-scroll -->
    <div bind:this={messagesEndRef} class="chat-container__scroll-anchor" aria-hidden="true"></div>
  </div>

  <!-- Connection status indicator -->
  {#if context.state.connectionStatus !== 'connected' && context.state.connectionStatus !== 'disconnected'}
    <div class="chat-container__status" role="status">
      {#if context.state.connectionStatus === 'connecting'}
        <span class="chat-container__status-indicator chat-container__status-indicator--connecting"></span>
        <span>Connecting...</span>
      {:else if context.state.connectionStatus === 'error'}
        <span class="chat-container__status-indicator chat-container__status-indicator--error"></span>
        <span>Connection error</span>
      {/if}
    </div>
  {/if}
</div>

<style>
  .chat-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0;
    background-color: var(--gr-semantic-background-primary, #ffffff);
    border-radius: var(--gr-radii-lg, 0.5rem);
    overflow: hidden;
    position: relative;
  }

  .chat-container__inner {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    overflow-y: auto;
    overflow-x: hidden;
    scroll-behavior: smooth;
  }

  .chat-container__scroll-anchor {
    height: 1px;
    flex-shrink: 0;
  }

  /* Connection status indicator */
  .chat-container__status {
    position: absolute;
    top: var(--gr-spacing-scale-2, 0.5rem);
    right: var(--gr-spacing-scale-2, 0.5rem);
    display: flex;
    align-items: center;
    gap: var(--gr-spacing-scale-2, 0.5rem);
    padding: var(--gr-spacing-scale-2, 0.5rem) var(--gr-spacing-scale-3, 0.75rem);
    background-color: var(--gr-semantic-background-secondary, #f3f4f6);
    border-radius: var(--gr-radii-full, 9999px);
    font-size: var(--gr-typography-fontSize-sm, 0.875rem);
    color: var(--gr-semantic-foreground-secondary, #6b7280);
    z-index: 10;
  }

  .chat-container__status-indicator {
    width: 0.5rem;
    height: 0.5rem;
    border-radius: var(--gr-radii-full, 9999px);
  }

  .chat-container__status-indicator--connecting {
    background-color: var(--gr-color-warning-500, #f59e0b);
    animation: pulse 1.5s ease-in-out infinite;
  }

  .chat-container__status-indicator--error {
    background-color: var(--gr-color-error-500, #ef4444);
  }

  /* Loading state */
  .chat-container--loading::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(
      90deg,
      transparent,
      var(--gr-color-primary-500, #3b82f6),
      transparent
    );
    animation: loading-bar 1.5s ease-in-out infinite;
  }

  /* Streaming state */
  .chat-container--streaming {
    /* Visual indicator that streaming is active */
  }

  /* Error state */
  .chat-container--error {
    border-color: var(--gr-color-error-300, #fca5a5);
  }

  /* Animations */
  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  @keyframes loading-bar {
    0% {
      transform: translateX(-100%);
    }
    100% {
      transform: translateX(100%);
    }
  }

  /* Dark mode */
  :global([data-theme='dark']) .chat-container {
    background-color: var(--gr-semantic-background-primary, #1f2937);
  }

  :global([data-theme='dark']) .chat-container__status {
    background-color: var(--gr-semantic-background-secondary, #374151);
    color: var(--gr-semantic-foreground-secondary, #9ca3af);
  }

  :global([data-theme='dark']) .chat-container--error {
    border-color: var(--gr-color-error-700, #b91c1c);
  }

  /* Mobile responsive */
  @media (max-width: 640px) {
    .chat-container {
      border-radius: 0;
    }

    .chat-container__status {
      top: var(--gr-spacing-scale-1, 0.25rem);
      right: var(--gr-spacing-scale-1, 0.25rem);
      padding: var(--gr-spacing-scale-1, 0.25rem) var(--gr-spacing-scale-2, 0.5rem);
      font-size: var(--gr-typography-fontSize-xs, 0.75rem);
    }
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .chat-container__inner {
      scroll-behavior: auto;
    }

    .chat-container__status-indicator--connecting {
      animation: none;
    }

    .chat-container--loading::after {
      animation: none;
    }
  }
</style>>>> | TYPE: content creation | DESC: Create ChatContainer.svelte component with Svelte 5 runes, context provider, auto-scroll, keyboard shortcuts, responsive layout, and dark mode support. Uses $derived.by() for complex class derivation per Svelte 5 docs.

## Priority
high

## END MODULE

## BEGIN MODULE

### Module: Update Chat Package Index Exports
Update the index.ts file to export the new ChatContainer component and enhanced context utilities from the renamed context.svelte.ts file.

## Description
This module updates `packages/shared/chat/src/index.ts` to:
- Export `ChatContainer` as `Container` (following the naming pattern of other packages)
- Update imports to use `context.svelte.js` instead of `context.js`
- Export all context utilities: `getChatContext`, `setChatContext`, `createChatContext`, `hasChatContext`
- Export new utility functions: `formatMessageTime`, `formatStreamDuration`, `getConnectionStatusText`
- Export the `ConnectionStatus` type
- Export all types from `types.ts`
- Update example documentation to use `Chat.Container` instead of `Chat.Root`

## Type
update

## Dependencies
Chat Context Implementation, Remove Old Context File, ChatContainer Component Implementation

## Files
packages/shared/chat/src/index.ts

## File Changes
- packages/shared/chat/src/index.ts: BEFORE: <<</**
 * Chat Component Suite
 *
 * AI chat interface components for building conversational UIs.
 * Supports streaming responses, tool calls, and configurable settings.
 *
 * @module @equaltoai/greater-components-chat
 *
 * @example Basic usage
 * ```svelte
 * <script>
 *   import * as Chat from '@equaltoai/greater-components-chat';
 *
 *   const handlers = {
 *     onSubmit: async (content) => {
 *       // Send message to AI backend
 *       const response = await fetch('/api/chat', {
 *         method: 'POST',
 *         body: JSON.stringify({ message: content }),
 *       });
 *       return response.json();
 *     },
 *   };
 * </script>
 *
 * <Chat.Root {handlers}>
 *   <Chat.Header title="AI Assistant" />
 *   <Chat.Messages />
 *   <Chat.Input placeholder="Type a message..." />
 * </Chat.Root>
 * ```
 *
 * @example With suggestions
 * ```svelte
 * <Chat.Root {handlers}>
 *   <Chat.Messages />
 *   <Chat.Suggestions
 *     suggestions={[
 *       { id: '1', text: 'Tell me a joke' },
 *       { id: '2', text: 'What can you help with?' },
 *     ]}
 *   />
 *   <Chat.Input />
 * </Chat.Root>
 * ```
 */

// Export types
export type {
  MessageRole,
  MessageStatus,
  ToolCallStatus,
  ToolCall,
  ChatMessage,
  ChatContainerProps,
  ChatMessageProps,
  ChatMessagesProps,
  ChatInputProps,
  ChatToolCallProps,
  ChatSuggestion,
  ChatSuggestionsProps,
  ChatHeaderProps,
  ChatSettingsState,
  ChatSettingsProps,
} from './types.js';

// Export context utilities
export type {
  ChatHandlers,
  ChatState,
  ChatContextValue,
} from './context.js';

export {
  createChatContext,
  getChatContext,
  setChatContext,
  hasChatContext,
} from './context.js';

// Component exports will be added as they are implemented:
// export { default as Root } from './Root.svelte';
// export { default as Container } from './Container.svelte';
// export { default as Header } from './Header.svelte';
// export { default as Messages } from './Messages.svelte';
// export { default as Message } from './Message.svelte';
// export { default as Input } from './Input.svelte';
// export { default as ToolCall } from './ToolCall.svelte';
// export { default as Suggestions } from './Suggestions.svelte';
// export { default as Settings } from './Settings.svelte';>>> | AFTER: <<</**
 * Chat Component Suite
 *
 * AI chat interface components for building conversational UIs.
 * Supports streaming responses, tool calls, and configurable settings.
 *
 * @module @equaltoai/greater-components-chat
 *
 * @example Basic usage
 * ```svelte
 * <script>
 *   import * as Chat from '@equaltoai/greater-components-chat';
 *
 *   const handlers = {
 *     onSubmit: async (content) => {
 *       // Send message to AI backend
 *       const response = await fetch('/api/chat', {
 *         method: 'POST',
 *         body: JSON.stringify({ message: content }),
 *       });
 *       return response.json();
 *     },
 *   };
 * </script>
 *
 * <Chat.Container {handlers}>
 *   <Chat.Header title="AI Assistant" />
 *   <Chat.Messages />
 *   <Chat.Input placeholder="Type a message..." />
 * </Chat.Container>
 * ```
 *
 * @example With suggestions
 * ```svelte
 * <Chat.Container {handlers}>
 *   <Chat.Messages />
 *   <Chat.Suggestions
 *     suggestions={[
 *       { id: '1', text: 'Tell me a joke' },
 *       { id: '2', text: 'What can you help with?' },
 *     ]}
 *   />
 *   <Chat.Input />
 * </Chat.Container>
 * ```
 */

// Export types
export type {
  MessageRole,
  MessageStatus,
  ToolCallStatus,
  ToolCall,
  ChatMessage,
  ChatContainerProps,
  ChatMessageProps,
  ChatMessagesProps,
  ChatInputProps,
  ChatToolCallProps,
  ChatSuggestion,
  ChatSuggestionsProps,
  ChatHeaderProps,
  ChatSettingsState,
  ChatSettingsProps,
} from './types.js';

// Export context utilities and types
export type {
  ChatHandlers,
  ChatState,
  ChatContextValue,
  ConnectionStatus,
} from './context.svelte.js';

export {
  createChatContext,
  getChatContext,
  setChatContext,
  hasChatContext,
  formatMessageTime,
  formatStreamDuration,
  getConnectionStatusText,
} from './context.svelte.js';

// Component exports
export { default as Container } from './ChatContainer.svelte';

// Additional component exports will be added as they are implemented:
// export { default as Header } from './Header.svelte';
// export { default as Messages } from './Messages.svelte';
// export { default as Message } from './Message.svelte';
// export { default as Input } from './Input.svelte';
// export { default as ToolCall } from './ToolCall.svelte';
// export { default as Suggestions } from './Suggestions.svelte';
// export { default as Settings } from './Settings.svelte';>>> | TYPE: content replacement | DESC: Update index.ts to import from context.svelte.js (renamed file), export ChatContainer as Container, add ConnectionStatus type export, add utility function exports (formatMessageTime, formatStreamDuration, getConnectionStatusText), and update example documentation to use Chat.Container

## Priority
high

## END MODULE

# END MODULES LIST