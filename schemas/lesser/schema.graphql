# Lesser GraphQL Schema

scalar Time
scalar Cursor
scalar Upload

# Enums
enum TimelineType {
  HOME
  PUBLIC
  LOCAL
  HASHTAG
  LIST
  DIRECT
  ACTOR
}

enum ActorType {
  PERSON
  GROUP
  APPLICATION
  SERVICE
  ORGANIZATION
}

enum ObjectType {
  NOTE
  ARTICLE
  IMAGE
  VIDEO
  QUESTION
  EVENT
  PAGE
}

enum Visibility {
  PUBLIC
  UNLISTED
  FOLLOWERS
  DIRECT
}

enum Period {
  HOUR
  DAY
  WEEK
  MONTH
  YEAR
}

enum ActivityType {
  CREATE
  UPDATE
  DELETE
  FOLLOW
  LIKE
  ANNOUNCE
  UNDO
  ACCEPT
  REJECT
  FLAG
}

enum TrustCategory {
  CONTENT
  BEHAVIOR
  TECHNICAL
}

# Core Types
type Actor {
  id: ID!
  username: String!
  domain: String
  displayName: String
  summary: String
  avatar: String
  header: String
  followers: Int!
  following: Int!
  statusesCount: Int!
  bot: Boolean!
  locked: Boolean!
  createdAt: Time!
  updatedAt: Time!
  fields: [Field!]!
  
  # Lesser enhancements
  trustScore: Float!
  reputation: Reputation
  vouches: [Vouch!]!
}

type Field {
  name: String!
  value: String!
  verifiedAt: Time
}

type Object {
  id: ID!
  type: ObjectType!
  actor: Actor!
  content: String!
  contentMap: [ContentMap!]!
  inReplyTo: Object
  visibility: Visibility!
  sensitive: Boolean!
  spoilerText: String
  attachments: [Attachment!]!
  tags: [Tag!]!
  mentions: [Mention!]!
  createdAt: Time!
  updatedAt: Time!
  poll: Poll
  
  # Engagement metrics
  repliesCount: Int!
  likesCount: Int!
  sharesCount: Int!
  
  # Lesser enhancements
  estimatedCost: Int!
  moderationScore: Float
  communityNotes: [CommunityNote!]!
  
  # Quote Posts extensions
  quoteUrl: String
  quoteable: Boolean!
  quotePermissions: QuotePermission!
  quoteContext: QuoteContext
  quoteCount: Int!
  quotes(first: Int, after: String): QuoteConnection!
}

type ContentMap {
  language: String!
  content: String!
}

type Attachment {
  id: ID!
  type: String!
  url: String!
  preview: String
  description: String
  blurhash: String
  width: Int
  height: Int
  duration: Float
}

type Tag {
  name: String!
  url: String!
}

type Mention {
  id: ID!
  username: String!
  domain: String
  url: String!
}

type Activity {
  id: ID!
  type: ActivityType!
  actor: Actor!
  object: Object
  target: Object
  published: Time!
  
  # Lesser enhancement
  cost: Int!
}

# Connections for pagination
type ObjectConnection {
  edges: [ObjectEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ObjectEdge {
  node: Object!
  cursor: Cursor!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
  endCursor: Cursor
}

type ActorListPage {
  actors: [Actor!]!
  nextCursor: Cursor
  totalCount: Int!
}

# Instance Metrics
type InstanceMetrics {
  activeUsers: Int!
  requestsPerMinute: Int!
  averageLatencyMs: Float!
  storageUsedGB: Float!
  estimatedMonthlyCost: Float!
  lastUpdated: Time!
}

type CostBreakdown {
  period: Period!
  totalCost: Float!
  dynamoDBCost: Float!
  s3StorageCost: Float!
  lambdaCost: Float!
  dataTransferCost: Float!
  breakdown: [CostItem!]!
}

type CostItem {
  operation: String!
  count: Int!
  cost: Float!
}

# Trust & Moderation
type TrustEdge {
  from: Actor!
  to: Actor!
  category: TrustCategory!
  score: Float!
  updatedAt: Time!
}

type ModerationDecision {
  id: ID!
  object: Object!
  decision: String!
  confidence: Float!
  evidence: [String!]!
  reviewers: [Actor!]!
  timestamp: Time!
}

type CommunityNote {
  id: ID!
  author: Actor!
  content: String!
  helpful: Int!
  notHelpful: Int!
  createdAt: Time!
}

# Notification type
type Notification {
  id: ID!
  type: String! # follow, mention, favourite, reblog
  account: Actor! # Who triggered the notification
  status: Object # Related status (if any)
  read: Boolean!
  createdAt: Time!
}

# Notification connection for pagination
type NotificationConnection {
  edges: [NotificationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NotificationEdge {
  node: Notification!
  cursor: Cursor!
}

type PushSubscription {
  id: ID!
  endpoint: String!
  keys: PushSubscriptionKeys!
  alerts: PushSubscriptionAlerts!
  policy: String!
  serverKey: String
  createdAt: Time
  updatedAt: Time
}

type PushSubscriptionKeys {
  auth: String!
  p256dh: String!
}

type PushSubscriptionAlerts {
  follow: Boolean!
  favourite: Boolean!
  reblog: Boolean!
  mention: Boolean!
  poll: Boolean!
  followRequest: Boolean!
  status: Boolean!
  update: Boolean!
  adminSignUp: Boolean!
  adminReport: Boolean!
}

# Quote Posts types
type QuoteContext {
  originalAuthor: Actor!
  originalNote: Object
  quoteAllowed: Boolean!
  quoteType: QuoteType!
  withdrawn: Boolean!
}

enum QuotePermission {
  EVERYONE
  FOLLOWERS
  NONE
}

enum QuoteType {
  FULL
  PARTIAL
  COMMENTARY
  REACTION
}

type QuoteConnection {
  edges: [QuoteEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type QuoteEdge {
  node: Object!
  cursor: Cursor!
}

# Quote Posts payloads
type WithdrawQuotePayload {
  success: Boolean!
  note: Object!
  withdrawnCount: Int!
}

type UpdateQuotePermissionsPayload {
  success: Boolean!
  note: Object!
  affectedQuotes: Int!
}

# Conversation type
type Conversation {
  id: ID!
  lastStatus: Object
  unread: Boolean!
  accounts: [Actor!]!
  createdAt: Time!
  updatedAt: Time!
}

# List type
type List {
  id: ID!
  title: String!
  repliesPolicy: RepliesPolicy!
  exclusive: Boolean!
  accountCount: Int!
  accounts: [Actor!]!
  createdAt: Time!
  updatedAt: Time!
}

enum RepliesPolicy {
  FOLLOWED
  LIST
  NONE
}

# Media type
type Media {
  id: ID!
  type: MediaType!
  url: String!
  previewUrl: String
  description: String
  sensitive: Boolean!
  spoilerText: String
  mediaCategory: MediaCategory!
  blurhash: String
  width: Int
  height: Int
  duration: Float
  size: Int!
  mimeType: String!
  uploadedBy: Actor!
  createdAt: Time!
}

enum MediaType {
  IMAGE
  VIDEO
  AUDIO
  UNKNOWN
}

enum MediaCategory {
  IMAGE
  VIDEO
  AUDIO
  GIFV
  DOCUMENT
  UNKNOWN
}

type MediaEdge {
  node: Media!
  cursor: Cursor!
}

type MediaConnection {
  edges: [MediaEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input MediaFilterInput {
  ownerId: ID
  ownerUsername: String
  mediaType: MediaType
  mimeType: String
  since: Time
  until: Time
}

# Custom Emoji type
type CustomEmoji {
  id: ID!
  shortcode: String!
  url: String!
  staticUrl: String!
  visibleInPicker: Boolean!
  category: String
  domain: String
  createdAt: Time!
  updatedAt: Time!
}

# Scheduled Status type
type ScheduledStatus {
  id: ID!
  scheduledAt: Time!
  params: StatusParams!
  mediaAttachments: [Media!]!
  createdAt: Time!
}

type StatusParams {
  text: String!
  visibility: Visibility!
  sensitive: Boolean!
  spoilerText: String
  inReplyToId: ID
  language: String
  poll: PollParams
}

type PollParams {
  options: [String!]!
  expiresIn: Int!
  multiple: Boolean
  hideTotals: Boolean
}

type Poll {
  id: ID!
  expiresAt: Time
  expired: Boolean!
  multiple: Boolean!
  hideTotals: Boolean!
  votesCount: Int!
  votersCount: Int!
  voted: Boolean!
  ownVotes: [Int!]
  options: [PollOption!]!
}

type PollOption {
  title: String!
  votesCount: Int!
}

# Enhanced Search types
type SearchResult {
  accounts: [Actor!]!
  statuses: [Object!]!
  hashtags: [Tag!]!
}

type AccountSuggestion {
  account: Actor!
  source: SuggestionSource!
  reason: String
}

enum SuggestionSource {
  STAFF
  PAST_INTERACTIONS
  GLOBAL
  SIMILAR_PROFILES
}

# Directory type for profile discovery
type ProfileDirectory {
  accounts: [Actor!]!
  totalCount: Int!
}

# Relationship type
type Relationship {
  id: ID!
  following: Boolean!
  followedBy: Boolean!
  blocking: Boolean!
  blockedBy: Boolean!
  muting: Boolean!
  mutingNotifications: Boolean!
  requested: Boolean!
  domainBlocking: Boolean!
  showingReblogs: Boolean!
  notifying: Boolean!
  languages: [String!]
  note: String
}

# Input Types
input CreateNoteInput {
  content: String!
  contentMap: [ContentMapInput!]
  inReplyToId: ID
  visibility: Visibility!
  sensitive: Boolean
  spoilerText: String
  attachmentIds: [ID!]
  mentions: [String!]
  tags: [String!]
  poll: PollParamsInput
}

input ContentMapInput {
  language: String!
  content: String!
}

input TrustInput {
  targetActorId: ID!
  category: TrustCategory!
  score: Float!
}

input FlagInput {
  objectId: ID!
  reason: String!
  evidence: [String!]
}

input CommunityNoteInput {
  objectId: ID!
  content: String!
}

input CreateQuoteNoteInput {
  content: String!
  quoteUrl: String!
  quoteType: QuoteType
  visibility: Visibility
  quoteable: Boolean
  sensitive: Boolean
  spoilerText: String
  mediaIds: [ID!]
}

# List inputs
input CreateListInput {
  title: String!
  repliesPolicy: RepliesPolicy
  exclusive: Boolean
}

input UpdateListInput {
  title: String
  repliesPolicy: RepliesPolicy
  exclusive: Boolean
}

# Media inputs
input UploadMediaInput {
  file: Upload!
  filename: String
  description: String
  focus: FocusInput
  sensitive: Boolean
  spoilerText: String
  mediaType: MediaCategory
}

input UpdateMediaInput {
  description: String
  focus: FocusInput
}

input FocusInput {
  x: Float!
  y: Float!
}

# Scheduled status inputs
input ScheduleStatusInput {
  text: String!
  scheduledAt: Time!
  visibility: Visibility
  sensitive: Boolean
  spoilerText: String
  inReplyToId: ID
  language: String
  mediaIds: [ID!]
  poll: PollParamsInput
}

input PollParamsInput {
  options: [String!]!
  expiresIn: Int!
  multiple: Boolean
  hideTotals: Boolean
}

input UpdateScheduledStatusInput {
  scheduledAt: Time!
}

# Relationship inputs
input UpdateRelationshipInput {
  notify: Boolean
  showReblogs: Boolean
  languages: [String!]
  note: String
}

input ProfileFieldInput {
  name: String!
  value: String!
  verifiedAt: Time
}

input UpdateProfileInput {
  displayName: String
  bio: String
  avatar: String
  header: String
  locked: Boolean
  bot: Boolean
  discoverable: Boolean
  noIndex: Boolean
  sensitive: Boolean
  language: String
  fields: [ProfileFieldInput!]
}

input PushSubscriptionKeysInput {
  auth: String!
  p256dh: String!
}

input PushSubscriptionAlertsInput {
  follow: Boolean
  favourite: Boolean
  reblog: Boolean
  mention: Boolean
  poll: Boolean
  followRequest: Boolean
  status: Boolean
  update: Boolean
  adminSignUp: Boolean
  adminReport: Boolean
}

input RegisterPushSubscriptionInput {
  endpoint: String!
  keys: PushSubscriptionKeysInput!
  alerts: PushSubscriptionAlertsInput!
}

input UpdatePushSubscriptionInput {
  alerts: PushSubscriptionAlertsInput!
}

# Emoji inputs
input CreateEmojiInput {
  shortcode: String!
  image: String! # URL or base64
  category: String
  visibleInPicker: Boolean
}

input UpdateEmojiInput {
  category: String
  visibleInPicker: Boolean
}

# Search/Discovery inputs
input DirectoryFiltersInput {
  local: Boolean
  remote: Boolean
  active: Boolean
  order: DirectoryOrder
}

enum DirectoryOrder {
  ACTIVE
  NEW
}

# Payloads
type CreateNotePayload {
  object: Object!
  activity: Activity!
  cost: CostUpdate!
}

type FlagPayload {
  moderationId: ID!
  queued: Boolean!
}

type CommunityNotePayload {
  note: CommunityNote!
  object: Object!
}

# Updates
type CostUpdate {
  operationCost: Int!
  dailyTotal: Float!
  monthlyProjection: Float!
}

# Queries
type Query {
  # Mastodon compatibility
  actor(id: ID, username: String): Actor
  object(id: ID!): Object
  timeline(
    type: TimelineType!
    hashtag: String
    listId: ID
    actorId: ID
    first: Int = 20
    after: Cursor
    mediaOnly: Boolean = false
  ): ObjectConnection!
  search(query: String!, type: String, first: Int = 20, after: Cursor): SearchResult!
  notifications(types: [String!], excludeTypes: [String!], first: Int = 20, after: Cursor): NotificationConnection!
  
  # Conversations
  conversations(first: Int = 20, after: Cursor): [Conversation!]!
  conversation(id: ID!): Conversation
  
  # Lists
  lists: [List!]!
  list(id: ID!): List
  listAccounts(id: ID!): [Actor!]!
  
  # Media
  media(id: ID!): Media
  mediaLibrary(filter: MediaFilterInput, first: Int = 20, after: Cursor): MediaConnection!
  
  # Custom Emojis
  customEmojis: [CustomEmoji!]!
  
  # Scheduled Statuses
  scheduledStatuses(first: Int = 20, after: Cursor): [ScheduledStatus!]!
  scheduledStatus(id: ID!): ScheduledStatus
  
  # Relationships
  relationship(id: ID!): Relationship
  relationships(ids: [ID!]!): [Relationship!]!
  followers(username: String!, limit: Int = 40, cursor: Cursor): ActorListPage!
  following(username: String!, limit: Int = 40, cursor: Cursor): ActorListPage!
  userPreferences: UserPreferences!
  pushSubscription: PushSubscription
  
  # Discovery
  profileDirectory(filters: DirectoryFiltersInput, first: Int = 40, after: Cursor): ProfileDirectory!
  suggestions(limit: Int = 40): [AccountSuggestion!]!
  removeSuggestion(accountId: ID!): Boolean!
  
  # Lesser enhancements
  instanceMetrics: InstanceMetrics!
  costBreakdown(period: Period = DAY): CostBreakdown!
  trustGraph(actorId: ID!, category: TrustCategory): [TrustEdge!]!
  moderationQueue(first: Int = 20, after: Cursor): [ModerationDecision!]!
  
  # Debug endpoints
  explainObject(id: ID!): ObjectExplanation!
  federationStatus(domain: String!): FederationStatus!
  
  # AI Analysis
  aiAnalysis(objectId: ID!): AIAnalysis
  aiStats(period: Period!): AIStats!
  aiCapabilities: AICapabilities!
  
  # Hashtag Following queries
  hashtag(name: String!): Hashtag
  followedHashtags(first: Int, after: String): HashtagConnection!
  hashtagTimeline(hashtag: String!, first: Int, after: String, mediaOnly: Boolean = false): PostConnection!
  multiHashtagTimeline(
    hashtags: [String!]!
    mode: HashtagMode!
    first: Int
    after: String
  ): PostConnection!
  suggestedHashtags(limit: Int): [HashtagSuggestion!]!
  
  # Thread Synchronization queries
  threadContext(noteId: ID!): ThreadContext
  
  # Severed Relationships queries
  severedRelationships(
    instance: String
    first: Int
    after: String
  ): SeveredRelationshipConnection!
  
  affectedRelationships(
    severedRelationshipId: ID!
  ): AffectedRelationshipConnection!
}

# Mutations
type Mutation {
  # Mastodon compatibility - Status operations
  createNote(input: CreateNoteInput!): CreateNotePayload!
  deleteObject(id: ID!): Boolean!
  likeObject(id: ID!): Activity!
  unlikeObject(id: ID!): Boolean!
  shareObject(id: ID!): Activity!
  unshareObject(id: ID!): Boolean!
  bookmarkObject(id: ID!): Object!
  unbookmarkObject(id: ID!): Boolean!
  pinObject(id: ID!): Object!
  unpinObject(id: ID!): Boolean!
  
  # Relationship operations
  followActor(id: ID!): Activity!
  unfollowActor(id: ID!): Boolean!
  blockActor(id: ID!): Relationship!
  unblockActor(id: ID!): Boolean!
  muteActor(id: ID!, notifications: Boolean): Relationship!
  unmuteActor(id: ID!): Boolean!
  updateRelationship(id: ID!, input: UpdateRelationshipInput!): Relationship!
  updateProfile(input: UpdateProfileInput!): Actor!
  
  # List operations
  createList(input: CreateListInput!): List!
  updateList(id: ID!, input: UpdateListInput!): List!
  deleteList(id: ID!): Boolean!
  addAccountsToList(id: ID!, accountIds: [ID!]!): List!
  removeAccountsFromList(id: ID!, accountIds: [ID!]!): List!
  
  # Conversation operations
  markConversationAsRead(id: ID!): Conversation!
  deleteConversation(id: ID!): Boolean!
  
  # Media operations
  uploadMedia(input: UploadMediaInput!): UploadMediaPayload!
  updateMedia(id: ID!, input: UpdateMediaInput!): Media!
  
  # Notification operations
  dismissNotification(id: ID!): Boolean!
  clearNotifications: Boolean!
  updateUserPreferences(input: UpdateUserPreferencesInput!): UserPreferences!
  updateStreamingPreferences(input: StreamingPreferencesInput!): UserPreferences!
  registerPushSubscription(input: RegisterPushSubscriptionInput!): PushSubscription!
  updatePushSubscription(input: UpdatePushSubscriptionInput!): PushSubscription!
  deletePushSubscription: Boolean!
  
  # Scheduled status operations
  scheduleStatus(input: ScheduleStatusInput!): ScheduledStatus!
  updateScheduledStatus(id: ID!, input: UpdateScheduledStatusInput!): ScheduledStatus!
  cancelScheduledStatus(id: ID!): Boolean!
  
  # Custom emoji operations (admin)
  createEmoji(input: CreateEmojiInput!): CustomEmoji!
  updateEmoji(shortcode: String!, input: UpdateEmojiInput!): CustomEmoji!
  deleteEmoji(shortcode: String!): Boolean!
  
  # Lesser enhancements
  updateTrust(input: TrustInput!): TrustEdge!
  flagObject(input: FlagInput!): FlagPayload!
  addCommunityNote(input: CommunityNoteInput!): CommunityNotePayload!
  voteCommunityNote(id: ID!, helpful: Boolean!): CommunityNote!
  
  # AI Analysis
  requestAIAnalysis(objectId: ID!, objectType: String, force: Boolean): AIAnalysisRequest!
  
  # Quote Posts mutations
  createQuoteNote(input: CreateQuoteNoteInput!): CreateNotePayload!
  withdrawFromQuotes(noteId: ID!): WithdrawQuotePayload!
  updateQuotePermissions(
    noteId: ID!
    quoteable: Boolean!
    permission: QuotePermission!
  ): UpdateQuotePermissionsPayload!
  
  # Hashtag Following mutations
  followHashtag(hashtag: String!, notifyLevel: NotificationLevel): HashtagFollowPayload!
  unfollowHashtag(hashtag: String!): UnfollowHashtagPayload!
  updateHashtagNotifications(
    hashtag: String!
    settings: HashtagNotificationSettingsInput!
  ): UpdateHashtagNotificationsPayload!
  muteHashtag(hashtag: String!, until: Time): MuteHashtagPayload!
  
  # Thread Synchronization mutations
  syncThread(noteUrl: String!, depth: Int): SyncThreadPayload!
  syncMissingReplies(noteId: ID!): SyncRepliesPayload!
  
  # Severed Relationships mutations
  acknowledgeSeverance(id: ID!): AcknowledgePayload!
  attemptReconnection(id: ID!): ReconnectionPayload!
}

type UploadMediaPayload {
  media: Media!
  uploadId: ID!
  warnings: [String!]
}

# Subscriptions (via WebSocket Lambda)
type Subscription {
  # Activity streams
  activityStream(types: [ActivityType!]): Activity!
  timelineUpdates(type: TimelineType!, listId: ID): Object!
  
  # Notification stream
  notificationStream(types: [String!]): Notification!
  
  # Conversation updates
  conversationUpdates: Conversation!
  
  # List updates
  listUpdates(listId: ID!): ListUpdate!
  
  # Relationship changes
  relationshipUpdates(actorId: ID): RelationshipUpdate!
  
  # Lesser enhancements
  costUpdates(threshold: Int): CostUpdate!
  moderationEvents(actorId: ID): ModerationDecision!
  trustUpdates(actorId: ID!): TrustEdge!
  
  # AI Analysis
  aiAnalysisUpdates(objectId: ID): AIAnalysis!
  
  # Quote Posts subscription
  quoteActivity(noteId: ID!): QuoteActivityUpdate!
  
  # Hashtag Following subscription
  hashtagActivity(hashtags: [String!]!): HashtagActivityUpdate!
  
  # Real-time Metrics Updates subscription
  metricsUpdates(categories: [String!], services: [String!], threshold: Float): MetricsUpdate!
}

# Quote activity update type
type QuoteActivityUpdate {
  type: String! # "quoted", "withdrawn", "permission_changed"
  quote: Object
  quoter: Actor
  timestamp: Time!
}

# List update type
type ListUpdate {
  type: String! # "created", "updated", "deleted", "account_added", "account_removed"
  list: List!
  account: Actor
  timestamp: Time!
}

# Relationship update type
type RelationshipUpdate {
  type: String! # "followed", "unfollowed", "blocked", "unblocked", "muted", "unmuted"
  relationship: Relationship!
  actor: Actor!
  timestamp: Time!
}

# Hashtag Following types
type Hashtag {
  name: String!
  displayName: String!
  url: String!
  followerCount: Int!
  postCount: Int!
  trendingScore: Float!
  isFollowing: Boolean!
  followedAt: Time
  notificationSettings: HashtagNotificationSettings
  posts(first: Int, after: String): PostConnection!
  relatedHashtags: [Hashtag!]!
  analytics: HashtagAnalytics!
}

type HashtagNotificationSettings {
  level: NotificationLevel!
  muted: Boolean!
  mutedUntil: Time
  filters: [NotificationFilter!]!
}

enum NotificationLevel {
  ALL
  MUTUALS
  FOLLOWING
  NONE
}

type NotificationFilter {
  type: String!
  value: String!
}

type PostConnection {
  edges: [PostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PostEdge {
  node: Object!
  cursor: Cursor!
}

type HashtagConnection {
  edges: [HashtagEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type HashtagEdge {
  node: Hashtag!
  cursor: Cursor!
}

type HashtagSuggestion {
  hashtag: Hashtag!
  reason: String!
  score: Float!
}

type HashtagAnalytics {
  hourlyPosts: [Int!]!
  dailyPosts: [Int!]!
  topPosters: [Actor!]!
  sentiment: Float!
  engagement: Float!
}

enum HashtagMode {
  ANY    # Posts with any of the hashtags
  ALL    # Posts with all of the hashtags
}

# Hashtag Following payloads
type HashtagFollowPayload {
  success: Boolean!
  hashtag: Hashtag!
}

type UnfollowHashtagPayload {
  success: Boolean!
  hashtag: Hashtag!
}

type UpdateHashtagNotificationsPayload {
  success: Boolean!
  hashtag: Hashtag!
  settings: HashtagNotificationSettings!
}

type MuteHashtagPayload {
  success: Boolean!
  hashtag: Hashtag!
  mutedUntil: Time
}

type HashtagActivityUpdate {
  hashtag: String!
  post: Object!
  author: Actor!
  timestamp: Time!
}

# Real-time metrics update type for GraphQL subscriptions
type MetricsUpdate {
  metricId: String!
  serviceName: String!
  metricType: String!
  subscriptionCategory: String! # moderation, security, performance, federation, cost, etc.
  aggregationLevel: String!     # raw, 5min, hourly, daily
  timestamp: Time!
  count: Int!
  sum: Float!
  min: Float!
  max: Float!
  average: Float!
  p50: Float
  p95: Float
  p99: Float
  unit: String
  userCostMicrocents: Int
  totalCostMicrocents: Int
  dimensions: [MetricsDimension!]!
  userId: String
  tenantId: String
  instanceDomain: String
}

# Key-value pair for metrics dimensions
type MetricsDimension {
  key: String!
  value: String!
}

input HashtagNotificationSettingsInput {
  level: NotificationLevel!
  muted: Boolean
  mutedUntil: Time
  filters: [NotificationFilterInput!]
}

input NotificationFilterInput {
  type: String!
  value: String!
}

# Debug types
type ObjectExplanation {
  object: Object!
  storageLocation: String!
  sizeBytes: Int!
  storageCost: Float!
  accessPattern: [AccessLog!]!
}

type AccessLog {
  timestamp: Time!
  operation: String!
  cost: Int!
}

type FederationStatus {
  domain: String!
  reachable: Boolean!
  lastContact: Time
  sharedInbox: String
  publicKey: String
  software: String
  version: String
}

# Reputation types
type Reputation {
  actorId: ID!
  instance: String!
  totalScore: Int!
  trustScore: Int!
  activityScore: Int!
  moderationScore: Int!
  communityScore: Int!
  calculatedAt: Time!
  version: String!
  evidence: ReputationEvidence!
  signature: String
}

type ReputationEvidence {
  totalPosts: Int!
  totalFollowers: Int!
  accountAge: Int!
  vouchCount: Int!
  trustingActors: Int!
  averageTrustScore: Float!
}

type Vouch {
  id: ID!
  from: Actor!
  to: Actor!
  confidence: Float!
  context: String!
  voucherReputation: Int!
  createdAt: Time!
  expiresAt: Time!
  active: Boolean!
  revoked: Boolean!
  revokedAt: Time
}

type PortableReputation {
  context: [String!]!
  type: String!
  actor: String!
  reputation: Reputation!
  vouches: [Vouch!]!
  issuedAt: Time!
  expiresAt: Time!
  issuer: String!
  issuerProof: String!
}

type ReputationVerificationResult {
  valid: Boolean!
  actorId: String!
  issuer: String!
  issuedAt: Time!
  expiresAt: Time!
  signatureValid: Boolean!
  notExpired: Boolean!
  issuerTrusted: Boolean!
  error: String
}

type ReputationImportResult {
  success: Boolean!
  actorId: String!
  previousScore: Int!
  importedScore: Int!
  vouchesImported: Int!
  message: String
  error: String
}

"""
AI Analysis types
"""
type AIAnalysis {
  id: ID!
  objectId: ID!
  objectType: String!
  textAnalysis: TextAnalysis
  imageAnalysis: ImageAnalysis
  aiDetection: AIDetection
  spamAnalysis: SpamAnalysis
  overallRisk: Float!
  moderationAction: ModerationAction!
  confidence: Float!
  analyzedAt: Time!
}

type TextAnalysis {
  sentiment: Sentiment!
  sentimentScores: SentimentScores!
  toxicityScore: Float!
  toxicityLabels: [String!]!
  containsPII: Boolean!
  dominantLanguage: String!
  entities: [Entity!]!
  keyPhrases: [String!]!
}

type SentimentScores {
  positive: Float!
  negative: Float!
  neutral: Float!
  mixed: Float!
}

type Entity {
  type: String!
  text: String!
  score: Float!
}

type ImageAnalysis {
  moderationLabels: [ModerationLabel!]!
  isNSFW: Boolean!
  nsfwConfidence: Float!
  violenceScore: Float!
  weaponsDetected: Boolean!
  detectedText: [String!]!
  textToxicity: Float!
  celebrityFaces: [Celebrity!]!
  deepfakeScore: Float!
}

type ModerationLabel {
  name: String!
  confidence: Float!
  parentName: String
}

type Celebrity {
  name: String!
  confidence: Float!
  urls: [String!]!
}

type AIDetection {
  aiGeneratedProbability: Float!
  generationModel: String
  patternConsistency: Float!
  styleDeviation: Float!
  semanticCoherence: Float!
  suspiciousPatterns: [String!]!
}

type SpamAnalysis {
  spamScore: Float!
  spamIndicators: [SpamIndicator!]!
  postingVelocity: Float!
  repetitionScore: Float!
  linkDensity: Float!
  followerRatio: Float!
  interactionRate: Float!
  accountAgeDays: Int!
}

type SpamIndicator {
  type: String!
  description: String!
  severity: Float!
}

type AIStats {
  period: String!
  totalAnalyses: Int!
  toxicContent: Int!
  spamDetected: Int!
  aiGenerated: Int!
  nsfwContent: Int!
  piiDetected: Int!
  toxicityRate: Float!
  spamRate: Float!
  aiContentRate: Float!
  nsfwRate: Float!
  moderationActions: ModerationActionCounts!
}

type ModerationActionCounts {
  none: Int!
  flag: Int!
  hide: Int!
  remove: Int!
  shadowBan: Int!
  review: Int!
}

type AIAnalysisRequest {
  message: String!
  objectId: ID!
  estimatedTime: String!
}

enum Sentiment {
  POSITIVE
  NEGATIVE
  NEUTRAL
  MIXED
}

enum ModerationAction {
  NONE
  FLAG
  HIDE
  REMOVE
  SHADOW_BAN
  REVIEW
}

type AICapabilities {
  textAnalysis: TextAnalysisCapabilities!
  imageAnalysis: ImageAnalysisCapabilities!
  aiDetection: AIDetectionCapabilities!
  moderationActions: [String!]!
  costPerAnalysis: CostBreakdown!
}

type TextAnalysisCapabilities {
  sentimentAnalysis: Boolean!
  toxicityDetection: Boolean!
  spamDetection: Boolean!
  piiDetection: Boolean!
  entityExtraction: Boolean!
  languageDetection: Boolean!
}

type ImageAnalysisCapabilities {
  nsfwDetection: Boolean!
  violenceDetection: Boolean!
  textExtraction: Boolean!
  celebrityRecognition: Boolean!
  deepfakeDetection: Boolean!
}

type AIDetectionCapabilities {
  aiGeneratedContent: Boolean!
  patternAnalysis: Boolean!
  styleConsistency: Boolean!
}

# Thread Synchronization types
type ThreadContext {
  rootNote: Object!
  replyCount: Int!
  participantCount: Int!
  lastActivity: Time!
  missingPosts: Int!
  syncStatus: SyncStatus!
}

enum SyncStatus {
  COMPLETE
  PARTIAL
  SYNCING
  FAILED
}

type SyncThreadPayload {
  success: Boolean!
  thread: ThreadContext!
  syncedPosts: Int!
  errors: [String!]
}

type SyncRepliesPayload {
  success: Boolean!
  syncedReplies: Int!
  thread: ThreadContext!
}

# Severed Relationships types
type SeveredRelationship {
  id: ID!
  localInstance: String!
  remoteInstance: String!
  reason: SeveranceReason!
  affectedFollowers: Int!
  affectedFollowing: Int!
  timestamp: Time!
  reversible: Boolean!
  details: SeveranceDetails
}

enum SeveranceReason {
  DOMAIN_BLOCK
  INSTANCE_DOWN
  DEFEDERATION
  POLICY_VIOLATION
  OTHER
}

type SeveranceDetails {
  description: String!
  metadata: [String!]!
  adminNotes: String
  autoDetected: Boolean!
}

type SeveredRelationshipConnection {
  edges: [SeveredRelationshipEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SeveredRelationshipEdge {
  node: SeveredRelationship!
  cursor: Cursor!
}

type AffectedRelationship {
  actor: Actor!
  relationshipType: String! # "follower" or "following"
  establishedAt: Time!
  lastInteraction: Time
}

type AffectedRelationshipConnection {
  edges: [AffectedRelationshipEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AffectedRelationshipEdge {
  node: AffectedRelationship!
  cursor: Cursor!
}

type AcknowledgePayload {
  success: Boolean!
  severedRelationship: SeveredRelationship!
  acknowledged: Boolean!
}

type ReconnectionPayload {
  success: Boolean!
  severedRelationship: SeveredRelationship!
  reconnected: Int!
  failed: Int!
  errors: [String!]
} 
# Lesser GraphQL Schema - Phase 2 Federation Enhancements

# Cost Analytics Dashboard Types
type FederationCost {
  domain: String!
  ingressBytes: Int!
  egressBytes: Int!
  requestCount: Int!
  errorRate: Float!
  monthlyCostUSD: Float!
  healthScore: Float!
  recommendation: String
  lastUpdated: Time!
  breakdown: CostBreakdown!
}

type FederationCostConnection {
  edges: [FederationCostEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FederationCostEdge {
  node: FederationCost!
  cursor: Cursor!
}

type InstanceHealthReport {
  domain: String!
  status: InstanceHealthStatus!
  metrics: InstanceHealthMetrics!
  issues: [HealthIssue!]!
  recommendations: [String!]!
  lastChecked: Time!
}

enum InstanceHealthStatus {
  HEALTHY
  WARNING
  CRITICAL
  OFFLINE
  UNKNOWN
}

type InstanceHealthMetrics {
  responseTime: Float!
  errorRate: Float!
  federationDelay: Float!
  queueDepth: Int!
  costEfficiency: Float!
}

type HealthIssue {
  type: String!
  severity: IssueSeverity!
  description: String!
  detectedAt: Time!
  impact: String!
}

enum IssueSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

# Media Streaming Integration Types
type MediaStream {
  id: ID!
  url: String!
  hlsPlaylistUrl: String
  dashManifestUrl: String
  thumbnailUrl: String!
  duration: Int!
  bitrates: [Bitrate!]!
  expiresAt: Time!
}

type Bitrate {
  quality: StreamQuality!
  bitsPerSecond: Int!
  width: Int!
  height: Int!
  codec: String!
}

enum StreamQuality {
  AUTO
  LOW     # 480p
  MEDIUM  # 720p
  HIGH    # 1080p
  ULTRA   # 4K
}

# Advanced Moderation Tools Types
type ModerationPattern {
  id: ID!
  pattern: String!
  type: PatternType!
  severity: ModerationSeverity!
  matchCount: Int!
  falsePositiveRate: Float!
  createdAt: Time!
  updatedAt: Time!
  createdBy: Actor!
  active: Boolean!
}

enum PatternType {
  REGEX
  KEYWORD
  PHRASE
  ML_PATTERN
}

enum ModerationSeverity {
  INFO
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type TrainingResult {
  success: Boolean!
  status: String!          # SUBMITTED, IN_PROGRESS, COMPLETED, FAILED
  jobId: String!           # Bedrock job ARN/ID
  jobName: String!         # Human-readable job name
  datasetS3Key: String!    # S3 key of training dataset
  modelVersion: String!    # Model version (empty when SUBMITTED)
  accuracy: Float!         # Training accuracy (0 when SUBMITTED)
  precision: Float!        # Training precision (0 when SUBMITTED)
  recall: Float!           # Training recall (0 when SUBMITTED)
  f1Score: Float!          # Training F1 score (0 when SUBMITTED)
  samplesUsed: Int!        # Number of training samples
  trainingTime: Int!       # Training duration in seconds (0 when SUBMITTED)
  improvements: [String!]! # Improvements (empty when SUBMITTED)
}

type ModerationAlert {
  id: ID!
  severity: ModerationSeverity!
  pattern: ModerationPattern
  content: Object!
  matchedText: String!
  confidence: Float!
  suggestedAction: ModerationAction!
  timestamp: Time!
  handled: Boolean!
}

# Federation Management Types
type FederationLimit {
  domain: String!
  ingressLimitMB: Int!
  egressLimitMB: Int!
  requestsPerMinute: Int!
  monthlyBudgetUSD: Float
  active: Boolean!
  createdAt: Time!
  updatedAt: Time!
}

type FederationManagementStatus {
  domain: String!
  status: FederationState!
  reason: String
  pausedUntil: Time
  limits: FederationLimit
  metrics: FederationMetrics!
}

enum FederationState {
  ACTIVE
  PAUSED
  LIMITED
  BLOCKED
  ERROR
}

type FederationMetrics {
  currentMonthCostUSD: Float!
  currentMonthRequests: Int!
  currentMonthBandwidthMB: Int!
  averageResponseTime: Float!
  errorRate: Float!
}

type InstanceBudget {
  domain: String!
  monthlyBudgetUSD: Float!
  currentSpendUSD: Float!
  remainingBudgetUSD: Float!
  projectedOverspend: Float
  alertThreshold: Float!
  autoLimit: Boolean!
  period: String!
}

# Input Types for Phase 2
input ModerationPatternInput {
  pattern: String!
  type: PatternType!
  severity: ModerationSeverity!
  active: Boolean
}

input ModerationSampleInput {
  objectId: ID!
  objectType: String!
  label: String!
  confidence: Float!
}

input BedrockTrainingOptions {
  baseModelId: String
  datasetS3Path: String
  outputS3Path: String
  maxTrainingTime: Int
  earlyStoppingEnabled: Boolean
}

input FederationLimitInput {
  ingressLimitMB: Int
  egressLimitMB: Int
  requestsPerMinute: Int
  monthlyBudgetUSD: Float
}

# Phase 2 Query Extensions
extend type Query {
  # Cost Analytics
  federationCosts(first: Int, after: String, orderBy: CostOrderBy): FederationCostConnection!
  instanceHealthReport(domain: String!): InstanceHealthReport!
  costProjections(period: Period!): CostProjection!
  
  # Media Streaming
  mediaStreamUrl(mediaId: ID!): MediaStream!
  supportedBitrates(mediaId: ID!): [Bitrate!]!
  
  # Advanced Moderation
  moderationPatterns(active: Boolean, severity: ModerationSeverity, first: Int, after: String): [ModerationPattern!]!
  moderationEffectiveness(patternId: ID!, period: ModerationPeriod!): ModerationEffectiveness!
  
  # Federation Management
  federationLimits(active: Boolean, first: Int, after: String): [FederationLimit!]!
  instanceBudgets(exceeded: Boolean): [InstanceBudget!]!
  federationHealth(threshold: Float): [FederationManagementStatus!]!
}

# Phase 2 Mutation Extensions
extend type Mutation {
  # Media Streaming
  requestStreamingUrl(mediaId: ID!, quality: StreamQuality): MediaStream!
  preloadMedia(mediaIds: [ID!]!): [MediaStream!]!
  
  # Advanced Moderation
  createModerationPattern(input: ModerationPatternInput!): ModerationPattern!
  updateModerationPattern(id: ID!, input: ModerationPatternInput!): ModerationPattern!
  deleteModerationPattern(id: ID!): Boolean!
  trainModerationModel(samples: [ModerationSampleInput!]!, options: BedrockTrainingOptions): TrainingResult!
  
  # Federation Management
  setFederationLimit(domain: String!, limit: FederationLimitInput!): FederationLimit!
  pauseFederation(domain: String!, reason: String!, until: Time): FederationManagementStatus!
  resumeFederation(domain: String!): FederationManagementStatus!
  setInstanceBudget(domain: String!, monthlyUSD: Float!, autoLimit: Boolean): InstanceBudget!
  
  # Cost Management
  optimizeFederationCosts(threshold: Float!): CostOptimizationResult!
}

# Phase 2 Subscription Extensions
extend type Subscription {
  # Moderation Alerts
  moderationAlerts(severity: ModerationSeverity): ModerationAlert!
  
  # Cost Alerts
  costAlerts(thresholdUSD: Float!): CostAlert!
  budgetAlerts(domain: String): BudgetAlert!
  
  # Federation Health
  federationHealthUpdates(domain: String): FederationHealthUpdate!
}

# Additional Phase 2 Types
type CostProjection {
  period: Period!
  currentCost: Float!
  projectedCost: Float!
  variance: Float!
  topDrivers: [Driver!]!
  recommendations: [String!]!
}

type Driver {
  type: String!
  domain: String
  cost: Float!
  percentOfTotal: Float!
  trend: Trend!
}

enum Trend {
  INCREASING
  STABLE
  DECREASING
}

type ModerationEffectiveness {
  patternId: ID!
  matchCount: Int!
  truePositives: Int!
  falsePositives: Int!
  missedCount: Int!
  precision: Float!
  recall: Float!
  f1Score: Float!
}

type CostOptimizationResult {
  optimized: Int!
  savedMonthlyUSD: Float!
  actions: [OptimizationAction!]!
}

type OptimizationAction {
  domain: String!
  action: String!
  savingsUSD: Float!
  impact: String!
}

type CostAlert {
  id: ID!
  type: String!
  amount: Float!
  threshold: Float!
  domain: String
  message: String!
  timestamp: Time!
}

type BudgetAlert {
  id: ID!
  domain: String!
  budgetUSD: Float!
  spentUSD: Float!
  percentUsed: Float!
  projectedOverspend: Float
  alertLevel: AlertLevel!
  timestamp: Time!
}

enum AlertLevel {
  INFO
  WARNING
  CRITICAL
}

type FederationHealthUpdate {
  domain: String!
  previousStatus: InstanceHealthStatus!
  currentStatus: InstanceHealthStatus!
  issues: [HealthIssue!]!
  timestamp: Time!
}

enum CostOrderBy {
  TOTAL_COST_DESC
  TOTAL_COST_ASC
  ERROR_RATE_DESC
  REQUEST_COUNT_DESC
  DOMAIN_ASC
}

enum ModerationPeriod {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
} # Lesser GraphQL Schema - Phase 3 Federation Visualization

# Federation Relationship Visualization Types
type FederationGraph {
  nodes: [InstanceNode!]!
  edges: [FederationEdge!]!
  clusters: [InstanceCluster!]!
  healthScore: Float!
}

type InstanceNode {
  domain: String!
  displayName: String!
  software: String!
  version: String!
  userCount: Int!
  statusCount: Int!
  federatingWith: Int!
  healthStatus: InstanceHealthStatus!
  coordinates: Coordinates!
  metadata: InstanceMetadata!
}

type Coordinates {
  x: Float!
  y: Float!
}

type InstanceMetadata {
  firstSeen: Time!
  lastActivity: Time!
  monthlyActiveUsers: Int!
  registrationsOpen: Boolean!
  approvalRequired: Boolean!
  primaryLanguage: String!
  description: String
}

type FederationEdge {
  source: String!
  target: String!
  weight: Float!
  volumePerDay: Int!
  errorRate: Float!
  latency: Float!
  bidirectional: Boolean!
  healthScore: Float!
}

type InstanceCluster {
  id: ID!
  name: String!
  members: [String!]!
  commonality: String!
  avgHealthScore: Float!
  totalVolume: Int!
  description: String!
}

type InstanceRelations {
  domain: String!
  directConnections: [InstanceConnection!]!
  indirectConnections: [InstanceConnection!]!
  blockedBy: [String!]!
  blocking: [String!]!
  federationScore: Float!
  recommendations: [FederationRecommendation!]!
}

type InstanceConnection {
  domain: String!
  connectionType: ConnectionType!
  strength: Float!
  volumeIn: Int!
  volumeOut: Int!
  sharedUsers: Int!
  lastActivity: Time!
}

enum ConnectionType {
  FOLLOWS
  MENTIONS
  REPLIES
  BOOSTS
  QUOTES
  MIXED
}

type FederationRecommendation {
  type: RecommendationType!
  priority: Priority!
  domain: String
  reason: String!
  potentialImpact: String!
  action: String!
}

enum RecommendationType {
  PERFORMANCE
  COST
  SECURITY
  CONNECTIVITY
  CONTENT
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type FederationFlow {
  topSources: [FlowNode!]!
  topDestinations: [FlowNode!]!
  volumeByHour: [HourlyVolume!]!
  costByInstance: [InstanceCost!]!
}

type FlowNode {
  domain: String!
  volume: Int!
  percentage: Float!
  trend: Trend!
  avgMessageSize: Int!
}

type HourlyVolume {
  hour: Time!
  inbound: Int!
  outbound: Int!
  errors: Int!
  avgLatency: Float!
}

type InstanceCost {
  domain: String!
  costUSD: Float!
  percentage: Float!
  breakdown: CostBreakdown!
}

# Streaming Analytics Types
type StreamingAnalytics {
  totalViews: Int!
  uniqueViewers: Int!
  averageWatchTime: Duration!
  qualityDistribution: [QualityStats!]!
  bufferingEvents: Int!
  completionRate: Float!
}

type QualityStats {
  quality: StreamQuality!
  viewCount: Int!
  percentage: Float!
  avgBandwidth: Float!
}

scalar Duration

type StreamConnection {
  edges: [StreamEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type StreamEdge {
  node: Stream!
  cursor: Cursor!
}

type Stream {
  id: ID!
  mediaId: ID!
  title: String!
  thumbnail: String!
  duration: Duration!
  viewCount: Int!
  quality: StreamQuality!
  popularity: Float!
  createdAt: Time!
}

type BandwidthReport {
  period: TimePeriod!
  totalGB: Float!
  peakMbps: Float!
  avgMbps: Float!
  byQuality: [QualityBandwidth!]!
  byHour: [HourlyBandwidth!]!
  cost: Float!
}

type QualityBandwidth {
  quality: StreamQuality!
  totalGB: Float!
  percentage: Float!
}

type HourlyBandwidth {
  hour: Time!
  totalGB: Float!
  peakMbps: Float!
}

enum TimePeriod {
  HOUR
  DAY
  WEEK
  MONTH
}

# Moderation Dashboard Types
type ModerationDashboard {
  pendingReviews: Int!
  recentDecisions: [ModerationDecision!]!
  topPatterns: [PatternStats!]!
  falsePositiveRate: Float!
  averageResponseTime: Duration!
  threatTrends: [ThreatTrend!]!
}

type PatternStats {
  pattern: ModerationPattern!
  matchCount: Int!
  accuracy: Float!
  lastMatch: Time!
  trend: Trend!
}

type ThreatTrend {
  type: String!
  severity: ModerationSeverity!
  count: Int!
  change: Float!
  instances: [String!]!
}

type ModeratorStats {
  moderatorId: ID!
  period: TimePeriod!
  decisionsCount: Int!
  avgResponseTime: Duration!
  accuracy: Float!
  overturned: Int!
  categories: [CategoryStats!]!
}

type CategoryStats {
  category: String!
  count: Int!
  accuracy: Float!
}

type ModerationItem {
  id: ID!
  content: Object!
  reportCount: Int!
  severity: ModerationSeverity!
  priority: Priority!
  assignedTo: Actor
  deadline: Time!
}

type ThreatAlert {
  id: ID!
  type: String!
  severity: ModerationSeverity!
  source: String!
  description: String!
  affectedInstances: [String!]!
  mitigationSteps: [String!]!
  timestamp: Time!
}

# Performance Monitoring Types
type PerformanceReport {
  service: ServiceCategory!
  p50Latency: Duration!
  p95Latency: Duration!
  p99Latency: Duration!
  errorRate: Float!
  throughput: Float!
  coldStarts: Int!
  period: TimePeriod!
}

enum ServiceCategory {
  GRAPHQL_API
  FEDERATION_DELIVERY
  MEDIA_PROCESSOR
  MODERATION_ENGINE
  SEARCH_INDEXER
  STREAMING_SERVICE
}

type QueryPerformance {
  query: String!
  count: Int!
  avgDuration: Duration!
  p95Duration: Duration!
  errorCount: Int!
  lastSeen: Time!
}

type InfrastructureStatus {
  healthy: Boolean!
  services: [ServiceStatus!]!
  databases: [DatabaseStatus!]!
  queues: [QueueStatus!]!
  alerts: [InfrastructureAlert!]!
}

type ServiceStatus {
  name: String!
  type: ServiceCategory!
  status: HealthStatus!
  uptime: Float!
  lastRestart: Time
  errorRate: Float!
}

enum HealthStatus {
  HEALTHY
  DEGRADED
  DOWN
  UNKNOWN
}

type DatabaseStatus {
  name: String!
  type: String!
  status: HealthStatus!
  connections: Int!
  latency: Duration!
  throughput: Float!
}

type QueueStatus {
  name: String!
  depth: Int!
  processingRate: Float!
  oldestMessage: Time
  dlqCount: Int!
}

type InfrastructureAlert {
  id: ID!
  service: String!
  severity: AlertSeverity!
  message: String!
  timestamp: Time!
  resolved: Boolean!
}

type PerformanceAlert {
  id: ID!
  service: ServiceCategory!
  metric: String!
  threshold: Float!
  actualValue: Float!
  severity: AlertSeverity!
  timestamp: Time!
}

type InfrastructureEvent {
  id: ID!
  type: InfrastructureEventType!
  service: String!
  description: String!
  impact: String!
  timestamp: Time!
}

enum InfrastructureEventType {
  DEPLOYMENT
  SCALING
  FAILURE
  RECOVERY
  MAINTENANCE
}

enum AlertSeverity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

# Input Types
input StreamingQualityInput {
  mediaId: ID!
  quality: StreamQuality!
  bufferingEvents: Int!
  watchTime: Int!
}

input StreamingPreferencesInput {
  defaultQuality: StreamQuality
  autoQuality: Boolean
  preloadNext: Boolean
  dataSaver: Boolean
}

input ReblogFilterInput {
  key: String!
  enabled: Boolean!
}

input UpdateUserPreferencesInput {
  language: String
  defaultPostingVisibility: Visibility
  defaultMediaSensitive: Boolean
  expandSpoilers: Boolean
  expandMedia: ExpandMediaPreference
  autoplayGifs: Boolean
  showFollowCounts: Boolean
  preferredTimelineOrder: TimelineOrder
  searchSuggestionsEnabled: Boolean
  personalizedSearchEnabled: Boolean
  reblogFilters: [ReblogFilterInput!]
  streaming: StreamingPreferencesInput
}

input ModerationFilter {
  severity: ModerationSeverity
  assignedTo: ID
  priority: Priority
  unhandled: Boolean
}

# Phase 3 Query Extensions
extend type Query {
  # Federation Visualization
  federationMap(depth: Int = 2): FederationGraph!
  instanceRelationships(domain: String!): InstanceRelations!
  federationFlow(period: TimePeriod!): FederationFlow!
  
  # Streaming Analytics
  streamingAnalytics(mediaId: ID!): StreamingAnalytics!
  popularStreams(first: Int!, after: String): StreamConnection!
  bandwidthUsage(period: TimePeriod!): BandwidthReport!
  
  # Moderation Dashboard
  moderationDashboard(filter: ModerationFilter): ModerationDashboard!
  patternEffectiveness(patternId: ID!): PatternStats!
  moderatorActivity(moderatorId: ID!, period: TimePeriod!): ModeratorStats!
  
  # Performance Monitoring
  performanceMetrics(service: ServiceCategory!): PerformanceReport!
  slowQueries(threshold: Duration!): [QueryPerformance!]!
  infrastructureHealth: InfrastructureStatus!
}

# Phase 3 Mutation Extensions
extend type Mutation {
  # Streaming Quality
  reportStreamingQuality(input: StreamingQualityInput!): StreamingQualityReport!
}

# Phase 3 Subscription Extensions
extend type Subscription {
  # Moderation Queue
  moderationQueueUpdate(priority: Priority): ModerationItem!
  threatIntelligence: ThreatAlert!
  
  # Performance Alerts
  performanceAlert(severity: AlertSeverity!): PerformanceAlert!
  infrastructureEvent: InfrastructureEvent!
}

# Additional Types
type StreamingQualityReport {
  success: Boolean!
  mediaId: ID!
  quality: StreamQuality!
  reportId: ID!
}

type UserPreferences {
  actorId: ID!
  posting: PostingPreferences!
  reading: ReadingPreferences!
  discovery: DiscoveryPreferences!
  streaming: StreamingPreferences!
  notifications: NotificationPreferences!
  privacy: PrivacyPreferences!
  reblogFilters: [ReblogFilter!]!
}

type PostingPreferences {
  defaultVisibility: Visibility!
  defaultSensitive: Boolean!
  defaultLanguage: String!
}

type ReadingPreferences {
  expandSpoilers: Boolean!
  expandMedia: ExpandMediaPreference!
  autoplayGifs: Boolean!
  timelineOrder: TimelineOrder!
}

type DiscoveryPreferences {
  showFollowCounts: Boolean!
  searchSuggestionsEnabled: Boolean!
  personalizedSearchEnabled: Boolean!
}

type StreamingPreferences {
  defaultQuality: StreamQuality!
  autoQuality: Boolean!
  preloadNext: Boolean!
  dataSaver: Boolean!
}

type NotificationPreferences {
  email: Boolean! # Always false - Email notifications are not supported by Lesser
  push: Boolean!
  inApp: Boolean!
  digest: DigestFrequency!
}

enum DigestFrequency {
  NEVER
  DAILY
  WEEKLY
  MONTHLY
}

type PrivacyPreferences {
  defaultVisibility: Visibility!
  indexable: Boolean!
  showOnlineStatus: Boolean!
}

type ReblogFilter {
  key: String!
  enabled: Boolean!
}

enum ExpandMediaPreference {
  DEFAULT
  SHOW_ALL
  HIDE_ALL
}

enum TimelineOrder {
  NEWEST
  OLDEST
}
